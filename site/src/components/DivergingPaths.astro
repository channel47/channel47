---
/**
 * DivergingPaths Component
 *
 * A canvas animation that visualizes "Same tools. Different outcomes."
 * Lines begin together on the left, traveling horizontally.
 * Most continue flat â€” a few gradually rise, separating from the pack.
 *
 * Metaphor: Everyone starts with the same tools/access.
 * Those who understand deeply take a different trajectory.
 * The gap widens over time.
 */

interface Props {
  class?: string;
}

const { class: className } = Astro.props;
const canvasId = `diverging-paths-${Math.random().toString(36).substr(2, 9)}`;
---

<div
  class={`diverging-paths ${className || ''}`.trim()}
  data-diverging-paths
>
  <canvas id={canvasId} class="diverging-paths__canvas" aria-hidden="true"></canvas>
</div>

<script>
  interface Line {
    baseY: number;       // Starting Y offset from center
    divergence: number;  // How much this line diverges (negative = rises)
    speed: number;       // Horizontal travel speed multiplier
    opacity: number;     // Line opacity
    phase: number;       // Animation phase offset (0-1)
    thickness: number;   // Line width
  }

  interface AnimationState {
    lines: Line[];
    width: number;
    height: number;
    containerHeight: number;
    overflowTop: number;
    time: number;
    animationId: number;
    isRunning: boolean;
    hasStarted: boolean;
    startTime: number;
    dpr: number;
  }

  function initDivergingPaths() {
    const containers = document.querySelectorAll('[data-diverging-paths]');

    containers.forEach((container) => {
      if (container.hasAttribute('data-initialized')) return;
      container.setAttribute('data-initialized', 'true');

      const canvas = container.querySelector('canvas') as HTMLCanvasElement;
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      // Configuration
      const config = {
        lineCount: 12,
        divergentCount: 3,
        maxDivergence: 0.18,
        lineSpacing: 8,
        trailLength: 0.65,
        cycleDuration: 12000,      // Slower: 12 seconds per cycle
        entranceDuration: 1500,
        edgeFade: 0.08,
      };

      // Animation state
      const state: AnimationState = {
        lines: [],
        width: 0,
        height: 0,
        containerHeight: 0,
        overflowTop: 0,
        time: 0,
        animationId: 0,
        isRunning: false,
        hasStarted: false,
        startTime: 0,
        dpr: 1,
      };

      // Create lines
      function createLines() {
        state.lines = [];

        const totalHeight = (config.lineCount - 1) * config.lineSpacing;
        const startY = -totalHeight / 2;

        // Pick which lines diverge (bias toward upper lines)
        const divergentIndices = new Set<number>();
        while (divergentIndices.size < config.divergentCount) {
          const index = Math.floor(Math.random() * (config.lineCount * 0.6));
          divergentIndices.add(index);
        }

        for (let i = 0; i < config.lineCount; i++) {
          const baseY = startY + i * config.lineSpacing;
          const isDivergent = divergentIndices.has(i);

          state.lines.push({
            baseY,
            divergence: isDivergent
              ? -(0.06 + Math.random() * config.maxDivergence)
              : 0,
            speed: 0.9 + Math.random() * 0.2,
            opacity: isDivergent ? 0.85 : 0.3 + Math.random() * 0.25,
            phase: Math.random(),
            thickness: isDivergent ? 1.5 : 1,
          });
        }

        // Sort so divergent lines draw on top
        state.lines.sort((a, b) => Math.abs(a.divergence) - Math.abs(b.divergence));
      }

      // Handle DPI scaling and canvas setup
      function setupCanvas() {
        const containerRect = (container as HTMLElement).getBoundingClientRect();
        const containerStyles = getComputedStyle(container as Element);
        const overflowTop = parseFloat(containerStyles.getPropertyValue('--overflow-top')) || 60;
        const dpr = window.devicePixelRatio || 1;

        const width = containerRect.width;
        const height = containerRect.height + overflowTop;

        state.width = width;
        state.height = height;
        state.containerHeight = containerRect.height;
        state.overflowTop = overflowTop;
        state.dpr = dpr;

        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);

        createLines();
      }

      function easeOutCubic(t: number): number {
        return 1 - Math.pow(1 - t, 3);
      }

      // Edge fade for left/right sides
      function getEdgeFade(x: number): number {
        const fadeWidth = state.width * config.edgeFade;
        if (x < fadeWidth) return x / fadeWidth;
        if (x > state.width - fadeWidth) return (state.width - x) / fadeWidth;
        return 1;
      }

      // Draw a single line
      function drawLine(line: Line, entranceProgress: number) {
        const { width, height, overflowTop, containerHeight } = state;
        const centerY = overflowTop + containerHeight / 2;

        // Calculate flow progress
        const adjustedTime = state.time * line.speed;
        const flowProgress = ((adjustedTime / config.cycleDuration) + line.phase) % 1;

        const lineLength = width * config.trailLength;
        const totalTravel = width + lineLength;
        const headX = -lineLength * 0.2 + flowProgress * totalTravel;
        const tailX = headX - lineLength;

        if (headX < 0 || tailX > width) return;

        // Build the path
        const segments = 50;
        const points: { x: number; y: number }[] = [];

        for (let i = 0; i <= segments; i++) {
          const t = i / segments;
          const x = tailX + t * lineLength;
          if (x < -20 || x > width + 20) continue;

          const canvasProgress = Math.max(0, Math.min(1, x / width));
          const divergenceAmount = line.divergence * Math.pow(canvasProgress, 2.5) * height;
          const y = centerY + line.baseY + divergenceAmount;

          points.push({ x, y });
        }

        if (points.length < 2) return;

        // Draw as single path
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }

        // Create gradient
        const gradientStartX = Math.max(0, tailX);
        const gradientEndX = Math.min(width, headX);
        const gradient = ctx.createLinearGradient(gradientStartX, 0, gradientEndX, 0);

        const baseOpacity = line.opacity * entranceProgress;
        const isDivergent = line.divergence !== 0;

        if (isDivergent) {
          // Divergent: color shifts from orange to gold along the line
          gradient.addColorStop(0, `oklch(68% 0.14 35 / 0)`);
          gradient.addColorStop(0.3, `oklch(70% 0.14 38 / ${baseOpacity * 0.5 * getEdgeFade(gradientStartX + 0.3 * (gradientEndX - gradientStartX))})`);
          gradient.addColorStop(0.6, `oklch(74% 0.15 45 / ${baseOpacity * 0.8})`);
          gradient.addColorStop(1, `oklch(78% 0.16 52 / ${baseOpacity * getEdgeFade(gradientEndX)})`);
        } else {
          // Flat lines: simple fade
          gradient.addColorStop(0, `oklch(68% 0.14 35 / 0)`);
          gradient.addColorStop(0.3, `oklch(68% 0.14 35 / ${baseOpacity * 0.3 * getEdgeFade(gradientStartX)})`);
          gradient.addColorStop(0.7, `oklch(68% 0.14 35 / ${baseOpacity * 0.7})`);
          gradient.addColorStop(1, `oklch(68% 0.14 35 / ${baseOpacity * getEdgeFade(gradientEndX)})`);
        }

        ctx.strokeStyle = gradient;
        ctx.lineWidth = line.thickness;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.stroke();

        // Small head dot for divergent lines
        if (isDivergent && headX > 0 && headX < width) {
          const head = points[points.length - 1];
          if (head) {
            ctx.beginPath();
            ctx.arc(head.x, head.y, 1.5, 0, Math.PI * 2);
            ctx.fillStyle = `oklch(80% 0.16 55 / ${baseOpacity * 0.8 * getEdgeFade(head.x)})`;
            ctx.fill();
          }
        }
      }

      function animate(timestamp: number) {
        if (!state.isRunning) return;

        if (!state.hasStarted) {
          state.startTime = timestamp;
          state.hasStarted = true;
        }

        state.time = timestamp - state.startTime;
        const entranceProgress = Math.min(1, easeOutCubic(state.time / config.entranceDuration));

        ctx.clearRect(0, 0, state.width, state.height);

        state.lines.forEach((line) => {
          drawLine(line, entranceProgress);
        });

        state.animationId = requestAnimationFrame(animate);
      }

      function start() {
        if (state.isRunning) return;
        state.isRunning = true;
        state.hasStarted = false;
        state.animationId = requestAnimationFrame(animate);
      }

      function pause() {
        state.isRunning = false;
        cancelAnimationFrame(state.animationId);
      }

      function handleVisibility() {
        if (document.hidden) {
          pause();
        } else if (container.hasAttribute('data-visible')) {
          start();
        }
      }

      document.addEventListener('visibilitychange', handleVisibility);

      let resizeTimeout: ReturnType<typeof setTimeout>;
      const resizeObserver = new ResizeObserver(() => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(setupCanvas, 100);
      });
      resizeObserver.observe(container);

      const intersectionObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              container.setAttribute('data-visible', 'true');
              start();
            } else {
              container.removeAttribute('data-visible');
              pause();
            }
          });
        },
        { threshold: 0.1 }
      );
      intersectionObserver.observe(container);

      setupCanvas();

      (container as HTMLElement & { destroy?: () => void }).destroy = () => {
        pause();
        clearTimeout(resizeTimeout);
        resizeObserver.disconnect();
        intersectionObserver.disconnect();
        document.removeEventListener('visibilitychange', handleVisibility);
      };
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initDivergingPaths);
  } else {
    initDivergingPaths();
  }

  document.addEventListener('astro:page-load', initDivergingPaths);
</script>

<style>
  .diverging-paths {
    --overflow-top: 80px;
    position: relative;
    width: 100%;
    height: 80px;
    overflow: visible;
  }

  @media (min-width: 768px) {
    .diverging-paths {
      --overflow-top: 100px;
      height: 110px;
    }
  }

  @media (min-width: 1024px) {
    .diverging-paths {
      --overflow-top: 130px;
      height: 130px;
    }
  }

  @media (min-width: 1280px) {
    .diverging-paths {
      --overflow-top: 160px;
      height: 150px;
    }
  }

  .diverging-paths__canvas {
    display: block;
    position: absolute;
    left: 0;
    width: 100%;
    top: calc(-1 * var(--overflow-top));
    height: calc(100% + var(--overflow-top));
    pointer-events: none;
  }

  @media (prefers-reduced-motion: reduce) {
    .diverging-paths__canvas {
      opacity: 0.5;
    }
  }
</style>
