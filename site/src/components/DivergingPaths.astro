---
/**
 * DivergingPaths Component — ASCII Art Edition
 *
 * True ASCII art aesthetic: horizontal data streams that diverge.
 * Think terminal output, data flowing, some breaking free and rising.
 * The constraint of characters creates the distinctive look.
 */

interface Props {
  class?: string;
}

const { class: className } = Astro.props;
const canvasId = `diverging-paths-${Math.random().toString(36).substr(2, 9)}`;
---

<div
  class={`diverging-paths ${className || ''}`.trim()}
  data-diverging-paths
>
  <canvas id={canvasId} class="diverging-paths__canvas" aria-hidden="true"></canvas>
</div>

<script>
  interface Particle {
    x: number;
    y: number;
    baseY: number;
    char: string;
    opacity: number;
    born: number;
  }

  interface Stream {
    baseY: number;
    divergence: number;
    speed: number;
    phase: number;
    particles: Particle[];
    nextSpawn: number;
    spawnInterval: number;
    isDivergent: boolean;
  }

  interface AnimationState {
    streams: Stream[];
    width: number;
    height: number;
    containerHeight: number;
    overflowTop: number;
    time: number;
    animationId: number;
    isRunning: boolean;
    hasStarted: boolean;
    startTime: number;
    dpr: number;
    charWidth: number;
    charHeight: number;
  }

  function initDivergingPaths() {
    const containers = document.querySelectorAll('[data-diverging-paths]');

    containers.forEach((container) => {
      if (container.hasAttribute('data-initialized')) return;
      container.setAttribute('data-initialized', 'true');

      const canvas = container.querySelector('canvas') as HTMLCanvasElement;
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      // Character palettes - carefully chosen for visual rhythm
      const CHARS = {
        // Horizontal flow - mix of weights for texture
        horizontal: '─━─━─═─━──────────'.split(''),
        // Rising angles - progressive steepness
        rising: ['─', '╱', '/', '/', '╱', '∕', '/', '⟋'],
        // Leader characters - bright, distinctive
        leaders: ['▸', '▹', '›', '>', '▸', '▹'],
        // Accent characters for divergent streams
        accents: ['◆', '◇', '●', '○', '◈'],
        // Subtle background particles
        dust: ['·', '∙', ':', '°', '˙', '.'],
      };

      // Configuration
      const config = {
        streamCount: 8,
        divergentCount: 3,
        maxDivergence: 0.5,
        streamSpacing: 16,
        particleLifetime: 12000,   // Longer lifetime for slower movement
        spawnRate: 150,            // Slower spawn rate
        baseSpeed: 0.018,          // Much slower base speed
        fontSize: 15,
        entranceDuration: 1200,
        dustCount: 20,
      };

      const state: AnimationState = {
        streams: [],
        width: 0,
        height: 0,
        containerHeight: 0,
        overflowTop: 0,
        time: 0,
        animationId: 0,
        isRunning: false,
        hasStarted: false,
        startTime: 0,
        dpr: 1,
        charWidth: 10,
        charHeight: 16,
      };

      // Dust particles for atmosphere
      let dustParticles: { x: number; y: number; char: string; drift: number; opacity: number }[] = [];

      function createStreams() {
        state.streams = [];

        const totalHeight = (config.streamCount - 1) * config.streamSpacing;
        const startY = -totalHeight / 2;

        // Pick divergent streams (from upper half)
        const divergentIndices = new Set<number>();
        const candidates = Array.from({ length: Math.floor(config.streamCount * 0.6) }, (_, i) => i);
        while (divergentIndices.size < config.divergentCount && candidates.length > 0) {
          const idx = Math.floor(Math.random() * candidates.length);
          divergentIndices.add(candidates[idx]);
          candidates.splice(idx, 1);
        }

        for (let i = 0; i < config.streamCount; i++) {
          const isDivergent = divergentIndices.has(i);

          state.streams.push({
            baseY: startY + i * config.streamSpacing,
            divergence: isDivergent ? -(0.15 + Math.random() * config.maxDivergence) : 0,
            speed: config.baseSpeed * (0.7 + Math.random() * 0.6),
            phase: Math.random() * Math.PI * 2,
            particles: [],
            nextSpawn: Math.random() * config.spawnRate,
            spawnInterval: config.spawnRate * (0.8 + Math.random() * 0.4),
            isDivergent,
          });
        }

        // Sort so divergent streams render on top
        state.streams.sort((a, b) => (a.isDivergent ? 1 : 0) - (b.isDivergent ? 1 : 0));

        // Create dust particles
        createDust();
      }

      function createDust() {
        dustParticles = [];
        for (let i = 0; i < config.dustCount; i++) {
          dustParticles.push({
            x: Math.random() * state.width,
            y: Math.random() * state.height,
            char: CHARS.dust[Math.floor(Math.random() * CHARS.dust.length)],
            drift: (Math.random() - 0.5) * 0.05,  // Much slower drift
            opacity: 0.08 + Math.random() * 0.1,
          });
        }
      }

      function setupCanvas() {
        const containerRect = (container as HTMLElement).getBoundingClientRect();
        const containerStyles = getComputedStyle(container as Element);
        const overflowTop = parseFloat(containerStyles.getPropertyValue('--overflow-top')) || 100;
        const dpr = window.devicePixelRatio || 1;

        const width = containerRect.width;
        const height = containerRect.height + overflowTop;

        state.width = width;
        state.height = height;
        state.containerHeight = containerRect.height;
        state.overflowTop = overflowTop;
        state.dpr = dpr;

        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);

        // Measure character dimensions
        ctx.font = `${config.fontSize}px 'Geist Mono', 'JetBrains Mono', monospace`;
        const metrics = ctx.measureText('─');
        state.charWidth = metrics.width || config.fontSize * 0.6;
        state.charHeight = config.fontSize;

        createStreams();
      }

      function getCharForAngle(progress: number, isDivergent: boolean): string {
        if (!isDivergent) {
          return CHARS.horizontal[Math.floor(Math.random() * CHARS.horizontal.length)];
        }
        // As progress increases, use steeper characters
        const idx = Math.min(
          CHARS.rising.length - 1,
          Math.floor(progress * CHARS.rising.length * 1.5)
        );
        return CHARS.rising[idx];
      }

      function getColor(divergeRatio: number, alpha: number, isLeader: boolean = false): string {
        if (isLeader) {
          // Leaders are brighter
          const l = 78 + 12 * divergeRatio;
          const c = 0.16 + 0.04 * divergeRatio;
          const h = 40 + 30 * divergeRatio;
          return `oklch(${l}% ${c} ${h} / ${alpha})`;
        }
        // Regular particles
        const l = 60 + 22 * divergeRatio;
        const c = 0.12 + 0.06 * divergeRatio;
        const h = 35 + 30 * divergeRatio;
        return `oklch(${l}% ${c} ${h} / ${alpha})`;
      }

      function spawnParticle(stream: Stream, time: number) {
        const progress = 0;
        stream.particles.push({
          x: -state.charWidth,
          y: stream.baseY,
          baseY: stream.baseY,
          char: getCharForAngle(progress, stream.isDivergent),
          opacity: stream.isDivergent ? 0.95 : 0.3 + Math.random() * 0.2,
          born: time,
        });
      }

      function updateStream(stream: Stream, time: number, deltaTime: number) {
        const centerY = state.overflowTop + state.containerHeight / 2;

        // Spawn new particles
        if (time >= stream.nextSpawn) {
          spawnParticle(stream, time);
          stream.nextSpawn = time + stream.spawnInterval;
        }

        // Update particles
        stream.particles = stream.particles.filter(p => {
          const age = time - p.born;
          if (age > config.particleLifetime) return false;

          // Move horizontally
          p.x += stream.speed * deltaTime;

          // Calculate vertical position based on x progress
          const progress = Math.max(0, Math.min(1, p.x / state.width));
          const divergeAmount = stream.divergence * Math.pow(progress, 2) * state.height;
          p.y = p.baseY + divergeAmount;

          // Update character based on progress
          if (stream.isDivergent && progress > 0.2) {
            p.char = getCharForAngle(progress, true);
          }

          // Fade based on age
          const lifePct = age / config.particleLifetime;
          if (lifePct > 0.7) {
            p.opacity *= 0.97;
          }

          return p.x < state.width + state.charWidth * 2;
        });
      }

      function drawStream(stream: Stream, entranceProgress: number) {
        const centerY = state.overflowTop + state.containerHeight / 2;

        ctx.font = `${config.fontSize}px 'Geist Mono', 'JetBrains Mono', monospace`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const particles = stream.particles;
        const len = particles.length;

        for (let i = 0; i < len; i++) {
          const p = particles[i];
          const screenY = centerY + p.y;

          // Skip if off screen
          if (p.x < -state.charWidth || p.x > state.width + state.charWidth) continue;
          if (screenY < -state.charHeight || screenY > state.height + state.charHeight) continue;

          // Edge fade
          let edgeFade = 1;
          const fadeZone = state.width * 0.12;
          if (p.x < fadeZone) edgeFade = p.x / fadeZone;
          if (p.x > state.width - fadeZone) edgeFade = (state.width - p.x) / fadeZone;
          edgeFade = Math.max(0, Math.min(1, edgeFade));

          const progress = Math.max(0, Math.min(1, p.x / state.width));
          const isLeader = i === len - 1;
          const alpha = p.opacity * entranceProgress * edgeFade;

          if (alpha < 0.02) continue;

          // Draw character
          const color = getColor(stream.isDivergent ? progress : 0, alpha, isLeader && stream.isDivergent);
          ctx.fillStyle = color;

          // Leader gets special treatment
          if (isLeader && stream.isDivergent) {
            const leaderChar = CHARS.leaders[Math.floor((state.time / 200) % CHARS.leaders.length)];
            ctx.fillText(leaderChar, p.x, screenY);

            // Subtle glow for divergent leaders
            ctx.beginPath();
            ctx.arc(p.x, screenY, config.fontSize * 0.6, 0, Math.PI * 2);
            ctx.fillStyle = getColor(progress, alpha * 0.12, true);
            ctx.fill();
          } else {
            ctx.fillText(p.char, p.x, screenY);
          }
        }

        // Draw accent marks along divergent streams
        if (stream.isDivergent && particles.length > 5) {
          const accentInterval = Math.floor(particles.length / 3);
          for (let i = accentInterval; i < particles.length - 1; i += accentInterval) {
            const p = particles[i];
            if (!p) continue;

            const progress = Math.max(0, Math.min(1, p.x / state.width));
            if (progress < 0.4) continue;

            const screenY = centerY + p.y;
            let edgeFade = 1;
            const fadeZone = state.width * 0.12;
            if (p.x < fadeZone) edgeFade = p.x / fadeZone;
            if (p.x > state.width - fadeZone) edgeFade = (state.width - p.x) / fadeZone;

            const alpha = p.opacity * entranceProgress * edgeFade * 0.4;
            ctx.fillStyle = getColor(progress, alpha, false);
            ctx.fillText(CHARS.accents[i % CHARS.accents.length], p.x, screenY - config.fontSize * 0.8);
          }
        }
      }

      function drawDust(entranceProgress: number) {
        ctx.font = `${config.fontSize * 0.7}px 'Geist Mono', monospace`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        dustParticles.forEach(d => {
          // Slow drift
          d.x += d.drift;
          d.y += d.drift * 0.5;

          // Wrap around
          if (d.x < 0) d.x = state.width;
          if (d.x > state.width) d.x = 0;
          if (d.y < 0) d.y = state.height;
          if (d.y > state.height) d.y = 0;

          ctx.fillStyle = `oklch(55% 0.02 50 / ${d.opacity * entranceProgress})`;
          ctx.fillText(d.char, d.x, d.y);
        });
      }

      let lastTime = 0;

      function animate(timestamp: number) {
        if (!state.isRunning) return;

        if (!state.hasStarted) {
          state.startTime = timestamp;
          state.hasStarted = true;
          lastTime = timestamp;
          // Skip first frame to avoid huge deltaTime
          state.animationId = requestAnimationFrame(animate);
          return;
        }

        state.time = timestamp - state.startTime;
        const deltaTime = Math.min(timestamp - lastTime, 50); // Cap deltaTime to avoid jumps
        lastTime = timestamp;

        const entranceProgress = Math.min(1, state.time / config.entranceDuration);

        // Clear with transparency (don't paint over content above)
        ctx.clearRect(0, 0, state.width, state.height);

        // Draw dust first (background)
        drawDust(entranceProgress);

        // Update and draw streams
        state.streams.forEach(stream => {
          updateStream(stream, state.time, deltaTime);
          drawStream(stream, entranceProgress);
        });

        state.animationId = requestAnimationFrame(animate);
      }

      function start() {
        if (state.isRunning) return;
        state.isRunning = true;
        state.hasStarted = false;
        lastTime = 0;
        state.animationId = requestAnimationFrame(animate);
      }

      function pause() {
        state.isRunning = false;
        cancelAnimationFrame(state.animationId);
      }

      function handleVisibility() {
        if (document.hidden) {
          pause();
        } else if (container.hasAttribute('data-visible')) {
          start();
        }
      }

      document.addEventListener('visibilitychange', handleVisibility);

      let resizeTimeout: ReturnType<typeof setTimeout>;
      const resizeObserver = new ResizeObserver(() => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(setupCanvas, 100);
      });
      resizeObserver.observe(container);

      const intersectionObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              container.setAttribute('data-visible', 'true');
              start();
            } else {
              container.removeAttribute('data-visible');
              pause();
            }
          });
        },
        { threshold: 0.1 }
      );
      intersectionObserver.observe(container);

      setupCanvas();

      (container as HTMLElement & { destroy?: () => void }).destroy = () => {
        pause();
        clearTimeout(resizeTimeout);
        resizeObserver.disconnect();
        intersectionObserver.disconnect();
        document.removeEventListener('visibilitychange', handleVisibility);
      };
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initDivergingPaths);
  } else {
    initDivergingPaths();
  }

  document.addEventListener('astro:page-load', initDivergingPaths);
</script>

<style>
  .diverging-paths {
    --overflow-top: 100px;
    position: relative;
    width: 100%;
    height: 100px;
    overflow: visible;
  }

  @media (min-width: 768px) {
    .diverging-paths {
      --overflow-top: 140px;
      height: 120px;
    }
  }

  @media (min-width: 1024px) {
    .diverging-paths {
      --overflow-top: 180px;
      height: 140px;
    }
  }

  @media (min-width: 1280px) {
    .diverging-paths {
      --overflow-top: 220px;
      height: 160px;
    }
  }

  .diverging-paths__canvas {
    display: block;
    position: absolute;
    left: 0;
    width: 100%;
    top: calc(-1 * var(--overflow-top));
    height: calc(100% + var(--overflow-top));
    pointer-events: none;
  }

  @media (prefers-reduced-motion: reduce) {
    .diverging-paths__canvas {
      opacity: 0.5;
    }
  }
</style>
