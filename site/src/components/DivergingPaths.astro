---
/**
 * DivergingPaths Component
 *
 * A canvas animation that visualizes "Same tools. Different outcomes."
 * Lines begin together on the left, traveling horizontally.
 * Most continue flat â€” a few gradually rise, separating from the pack.
 *
 * Metaphor: Everyone starts with the same tools/access.
 * Those who understand deeply take a different trajectory.
 * The gap widens over time.
 */

interface Props {
  class?: string;
}

const { class: className } = Astro.props;
const canvasId = `diverging-paths-${Math.random().toString(36).substr(2, 9)}`;
---

<div
  class={`diverging-paths ${className || ''}`.trim()}
  data-diverging-paths
>
  <canvas id={canvasId} class="diverging-paths__canvas" aria-hidden="true"></canvas>
</div>

<script>
  interface Line {
    y: number;           // Current Y position (relative to center)
    baseY: number;       // Starting Y offset from center
    divergence: number;  // How much this line diverges (0 = flat, positive = rises)
    speed: number;       // Horizontal travel speed
    opacity: number;     // Line opacity
    phase: number;       // Animation phase offset
    thickness: number;   // Line width
  }

  interface AnimationState {
    lines: Line[];
    width: number;
    height: number;
    containerHeight: number;
    overflowTop: number;
    time: number;
    animationId: number;
    isRunning: boolean;
    hasStarted: boolean;
    startTime: number;
    dpr: number;
  }

  function initDivergingPaths() {
    const containers = document.querySelectorAll('[data-diverging-paths]');

    containers.forEach((container) => {
      if (container.hasAttribute('data-initialized')) return;
      container.setAttribute('data-initialized', 'true');

      const canvas = container.querySelector('canvas') as HTMLCanvasElement;
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      // Configuration
      const config = {
        lineCount: 12,
        divergentCount: 3,         // How many lines diverge upward
        maxDivergence: 0.25,       // Maximum angle of divergence (as ratio of height)
        baseSpeed: 0.3,            // Base horizontal speed
        lineSpacing: 8,            // Vertical spacing between lines at origin
        trailLength: 0.7,          // How much of canvas width the trail covers
        entranceDuration: 1500,    // ms for lines to fade in
        edgeFade: 0.08,            // Percentage of width for edge fade
      };

      // Animation state
      const state: AnimationState = {
        lines: [],
        width: 0,
        height: 0,
        containerHeight: 0,
        overflowTop: 0,
        time: 0,
        animationId: 0,
        isRunning: false,
        hasStarted: false,
        startTime: 0,
        dpr: 1,
      };

      // Create lines
      function createLines() {
        state.lines = [];

        // Calculate total height of line cluster
        const totalHeight = (config.lineCount - 1) * config.lineSpacing;
        const startY = -totalHeight / 2;

        // Determine which lines will diverge (pick from upper portion)
        const divergentIndices = new Set<number>();
        while (divergentIndices.size < config.divergentCount) {
          // Bias toward upper lines for divergence
          const index = Math.floor(Math.random() * (config.lineCount * 0.6));
          divergentIndices.add(index);
        }

        for (let i = 0; i < config.lineCount; i++) {
          const baseY = startY + i * config.lineSpacing;
          const isDivergent = divergentIndices.has(i);

          state.lines.push({
            y: baseY,
            baseY,
            divergence: isDivergent
              ? -(0.08 + Math.random() * config.maxDivergence) // Negative = rises (y decreases)
              : 0,
            speed: config.baseSpeed * (0.9 + Math.random() * 0.2),
            opacity: isDivergent ? 0.9 : 0.35 + Math.random() * 0.25,
            phase: Math.random() * Math.PI * 2,
            thickness: isDivergent ? 1.5 : 1,
          });
        }

        // Sort by divergence so divergent lines draw on top
        state.lines.sort((a, b) => Math.abs(a.divergence) - Math.abs(b.divergence));
      }

      // Handle DPI scaling and canvas setup
      function setupCanvas() {
        // Get container dimensions (not canvas, since canvas is absolutely positioned)
        const containerRect = (container as HTMLElement).getBoundingClientRect();
        const containerStyles = getComputedStyle(container as Element);
        const overflowTop = parseFloat(containerStyles.getPropertyValue('--overflow-top')) || 60;

        const dpr = window.devicePixelRatio || 1;

        // Calculate actual dimensions
        const width = containerRect.width;
        const height = containerRect.height + overflowTop;

        state.width = width;
        state.height = height;
        state.containerHeight = containerRect.height;
        state.overflowTop = overflowTop;
        state.dpr = dpr;

        // Set canvas buffer size
        canvas.width = width * dpr;
        canvas.height = height * dpr;

        // Set display size
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;

        // Reset and scale context
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);

        createLines();
      }

      // Easing function for entrance
      function easeOutCubic(t: number): number {
        return 1 - Math.pow(1 - t, 3);
      }

      // Calculate edge fade multiplier (0 at edges, 1 in center)
      function getEdgeFade(x: number): number {
        const fadeWidth = state.width * config.edgeFade;
        if (x < fadeWidth) {
          return x / fadeWidth;
        }
        if (x > state.width - fadeWidth) {
          return (state.width - x) / fadeWidth;
        }
        return 1;
      }

      // Get color for divergence amount - shifts from warm orange to brighter gold
      function getColorString(divergeRatio: number, opacity: number): string {
        // Base: oklch(68% 0.14 35) - warm orange
        // Target: oklch(80% 0.16 55) - brighter gold
        const l = 68 + 12 * divergeRatio;
        const c = 0.14 + 0.02 * divergeRatio;
        const h = 35 + 20 * divergeRatio;
        return `oklch(${l}% ${c} ${h} / ${opacity})`;
      }

      // Draw a single line with gradient trail
      function drawLine(line: Line, entranceProgress: number) {
        const { width, height, overflowTop, containerHeight } = state;

        // Visual center is in the middle of the visible container area
        // (accounting for overflow space at top)
        const centerY = overflowTop + containerHeight / 2;

        // Flow speed - lines move continuously from left to right
        const cycleDuration = 8000; // 8 seconds to complete one cycle
        const flowProgress = ((state.time * line.speed + line.phase * 1000) % cycleDuration) / cycleDuration;

        // Line length as portion of canvas width
        const lineLength = width * config.trailLength;

        // Calculate start and end X positions based on flow
        const totalTravel = width + lineLength;
        const headX = -lineLength * 0.2 + flowProgress * totalTravel;
        const tailX = headX - lineLength;

        // Only draw if visible
        if (headX < 0 || tailX > width) return;

        // Calculate points along the line
        const segments = 50;
        const points: { x: number; y: number; t: number }[] = [];

        for (let i = 0; i <= segments; i++) {
          const t = i / segments;
          const x = tailX + t * lineLength;

          // Skip points too far outside visible area
          if (x < -20 || x > width + 20) continue;

          // Divergence accelerates as lines move right across canvas
          const canvasProgress = Math.max(0, Math.min(1, x / width));
          const divergenceAmount = line.divergence * Math.pow(canvasProgress, 2.5) * height;
          const y = centerY + line.baseY + divergenceAmount;

          points.push({ x, y, t });
        }

        if (points.length < 2) return;

        const baseOpacity = line.opacity * entranceProgress;
        const isDivergent = line.divergence !== 0;

        // Draw the line as connected segments with varying opacity
        // This batches into fewer draw calls while still achieving the gradient effect
        if (isDivergent) {
          // For divergent lines: draw in color bands for performance
          // Group segments by similar divergence ratios
          const bandCount = 5;

          for (let band = 0; band < bandCount; band++) {
            const bandStart = band / bandCount;
            const bandEnd = (band + 1) / bandCount;
            const bandMid = (bandStart + bandEnd) / 2;

            // Calculate diverge ratio at band midpoint
            const divergeRatio = Math.pow(bandMid, 1.5);
            const bandColor = getColorString(divergeRatio, 1);

            ctx.beginPath();
            let hasStarted = false;

            for (let i = 0; i < points.length; i++) {
              const point = points[i];
              const pointT = point.t;

              // Check if point falls in this band
              if (pointT >= bandStart && pointT <= bandEnd) {
                // Calculate opacity based on position along line (fade at tail)
                let segmentOpacity = baseOpacity;
                if (pointT < 0.35) {
                  segmentOpacity = baseOpacity * (pointT / 0.35);
                } else if (pointT > 0.85) {
                  segmentOpacity = baseOpacity * (1 - (pointT - 0.85) / 0.15) * 0.5 + baseOpacity * 0.5;
                }

                // Apply edge fade
                const edgeFade = getEdgeFade(point.x);
                segmentOpacity *= edgeFade;

                if (!hasStarted) {
                  ctx.moveTo(point.x, point.y);
                  hasStarted = true;
                } else {
                  ctx.lineTo(point.x, point.y);
                }
              }
            }

            if (hasStarted) {
              // Use the band's color with a gradient for opacity
              const gradient = ctx.createLinearGradient(
                Math.max(0, tailX + bandStart * lineLength), 0,
                Math.min(width, tailX + bandEnd * lineLength), 0
              );

              const startOpacity = baseOpacity * (bandStart < 0.35 ? bandStart / 0.35 : 1) * getEdgeFade(tailX + bandStart * lineLength);
              const endOpacity = baseOpacity * (bandEnd < 0.35 ? bandEnd / 0.35 : 1) * getEdgeFade(tailX + bandEnd * lineLength);

              gradient.addColorStop(0, getColorString(Math.pow(bandStart, 1.5), startOpacity));
              gradient.addColorStop(1, getColorString(Math.pow(bandEnd, 1.5), endOpacity));

              ctx.strokeStyle = gradient;
              ctx.lineWidth = line.thickness;
              ctx.lineCap = 'round';
              ctx.lineJoin = 'round';
              ctx.stroke();
            }
          }

          // Draw head point for divergent lines
          if (headX > 0 && headX < width) {
            const head = points[points.length - 1];
            if (head) {
              const headOpacity = baseOpacity * getEdgeFade(head.x);
              ctx.beginPath();
              ctx.arc(head.x, head.y, 2.5, 0, Math.PI * 2);
              ctx.fillStyle = getColorString(1, headOpacity);
              ctx.fill();
            }
          }
        } else {
          // Non-divergent lines: draw as single path with horizontal gradient
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);

          for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
          }

          // Create gradient for the line (tail fades, head is solid)
          const gradientStartX = Math.max(0, tailX);
          const gradientEndX = Math.min(width, headX);
          const gradient = ctx.createLinearGradient(gradientStartX, 0, gradientEndX, 0);

          // Calculate edge fade at start and end
          const startEdgeFade = getEdgeFade(gradientStartX);
          const endEdgeFade = getEdgeFade(gradientEndX);

          gradient.addColorStop(0, `oklch(68% 0.14 35 / 0)`);
          gradient.addColorStop(0.3, `oklch(68% 0.14 35 / ${baseOpacity * 0.3 * startEdgeFade})`);
          gradient.addColorStop(0.7, `oklch(68% 0.14 35 / ${baseOpacity * 0.8})`);
          gradient.addColorStop(1, `oklch(68% 0.14 35 / ${baseOpacity * endEdgeFade})`);

          ctx.strokeStyle = gradient;
          ctx.lineWidth = line.thickness;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.stroke();
        }
      }

      // Main animation loop
      function animate(timestamp: number) {
        if (!state.isRunning) return;

        if (!state.hasStarted) {
          state.startTime = timestamp;
          state.hasStarted = true;
        }

        state.time = timestamp - state.startTime;

        // Calculate entrance progress (0 to 1 over entrance duration)
        const entranceProgress = Math.min(1, easeOutCubic(state.time / config.entranceDuration));

        // Clear canvas
        ctx.clearRect(0, 0, state.width, state.height);

        // Draw all lines
        state.lines.forEach((line) => {
          drawLine(line, entranceProgress);
        });

        state.animationId = requestAnimationFrame(animate);
      }

      // Start animation
      function start() {
        if (state.isRunning) return;
        state.isRunning = true;
        state.hasStarted = false;
        state.animationId = requestAnimationFrame(animate);
      }

      // Pause animation
      function pause() {
        state.isRunning = false;
        cancelAnimationFrame(state.animationId);
      }

      // Handle visibility changes
      function handleVisibility() {
        if (document.hidden) {
          pause();
        } else if (container.hasAttribute('data-visible')) {
          start();
        }
      }

      document.addEventListener('visibilitychange', handleVisibility);

      // Handle resize with debounce
      let resizeTimeout: ReturnType<typeof setTimeout>;
      const resizeObserver = new ResizeObserver(() => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          setupCanvas();
        }, 100);
      });
      resizeObserver.observe(container);

      // Intersection observer to start animation when visible
      const intersectionObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              container.setAttribute('data-visible', 'true');
              start();
            } else {
              container.removeAttribute('data-visible');
              pause();
            }
          });
        },
        { threshold: 0.1 }
      );
      intersectionObserver.observe(container);

      // Initial setup
      setupCanvas();

      // Cleanup function (exposed for potential external use)
      (container as HTMLElement & { destroy?: () => void }).destroy = () => {
        pause();
        clearTimeout(resizeTimeout);
        resizeObserver.disconnect();
        intersectionObserver.disconnect();
        document.removeEventListener('visibilitychange', handleVisibility);
      };
    });
  }

  // Initialize on load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initDivergingPaths);
  } else {
    initDivergingPaths();
  }

  // Also run on Astro view transitions
  document.addEventListener('astro:page-load', initDivergingPaths);
</script>

<style>
  .diverging-paths {
    --overflow-top: 80px;
    position: relative;
    width: 100%;
    height: 80px;
    overflow: visible;
  }

  @media (min-width: 768px) {
    .diverging-paths {
      --overflow-top: 100px;
      height: 110px;
    }
  }

  @media (min-width: 1024px) {
    .diverging-paths {
      --overflow-top: 130px;
      height: 130px;
    }
  }

  @media (min-width: 1280px) {
    .diverging-paths {
      --overflow-top: 160px;
      height: 150px;
    }
  }

  .diverging-paths__canvas {
    display: block;
    position: absolute;
    left: 0;
    width: 100%;
    /* Canvas extends above container */
    top: calc(-1 * var(--overflow-top));
    height: calc(100% + var(--overflow-top));
    pointer-events: none;
  }

  /* Reduced motion: show static state */
  @media (prefers-reduced-motion: reduce) {
    .diverging-paths__canvas {
      opacity: 0.5;
    }
  }
</style>
