---
/**
 * DivergingPaths Component — ASCII Edition
 *
 * Reimagined as flowing ASCII character streams.
 * Lines of dashes flow horizontally; some curve upward using angled characters.
 * Evokes terminal aesthetics while maintaining the "gap widening" metaphor.
 */

interface Props {
  class?: string;
}

const { class: className } = Astro.props;
const canvasId = `diverging-paths-${Math.random().toString(36).substr(2, 9)}`;
---

<div
  class={`diverging-paths ${className || ''}`.trim()}
  data-diverging-paths
>
  <canvas id={canvasId} class="diverging-paths__canvas" aria-hidden="true"></canvas>
</div>

<script>
  interface Stream {
    baseY: number;           // Starting Y position
    divergence: number;      // 0 = flat, negative = rises
    speed: number;           // Flow speed
    phase: number;           // Animation offset
    opacity: number;
    charSet: string[];       // Characters to use
    charWidth: number;       // Width of each character cell
  }

  interface AnimationState {
    streams: Stream[];
    width: number;
    height: number;
    containerHeight: number;
    overflowTop: number;
    time: number;
    animationId: number;
    isRunning: boolean;
    hasStarted: boolean;
    startTime: number;
    dpr: number;
    fontSize: number;
  }

  function initDivergingPaths() {
    const containers = document.querySelectorAll('[data-diverging-paths]');

    containers.forEach((container) => {
      if (container.hasAttribute('data-initialized')) return;
      container.setAttribute('data-initialized', 'true');

      const canvas = container.querySelector('canvas') as HTMLCanvasElement;
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      // ASCII character sets
      const CHARS = {
        flat: ['─', '─', '─', '─', '━', '─', '─', '—'],
        rising: ['/', '╱', '/', '⟋', '/'],
        head: ['█', '▌', '▐', '●'],
        fade: ['·', '∙', ':', '.'],
      };

      // Configuration
      const config = {
        streamCount: 10,
        divergentCount: 3,
        maxDivergence: 0.35,
        streamSpacing: 14,
        trailLength: 24,          // Number of characters in trail
        cycleDuration: 10000,
        baseSpeed: 0.25,
        entranceDuration: 1200,
        fontSize: 14,
        edgeFade: 0.1,
      };

      // Animation state
      const state: AnimationState = {
        streams: [],
        width: 0,
        height: 0,
        containerHeight: 0,
        overflowTop: 0,
        time: 0,
        animationId: 0,
        isRunning: false,
        hasStarted: false,
        startTime: 0,
        dpr: 1,
        fontSize: config.fontSize,
      };

      // Create streams
      function createStreams() {
        state.streams = [];

        const totalHeight = (config.streamCount - 1) * config.streamSpacing;
        const startY = -totalHeight / 2;

        // Pick which streams diverge
        const divergentIndices = new Set<number>();
        while (divergentIndices.size < config.divergentCount) {
          const index = Math.floor(Math.random() * (config.streamCount * 0.5));
          divergentIndices.add(index);
        }

        // Measure character width
        ctx.font = `${state.fontSize}px 'Geist Mono', 'SF Mono', Consolas, monospace`;
        const charWidth = ctx.measureText('─').width || state.fontSize * 0.6;

        for (let i = 0; i < config.streamCount; i++) {
          const baseY = startY + i * config.streamSpacing;
          const isDivergent = divergentIndices.has(i);

          state.streams.push({
            baseY,
            divergence: isDivergent
              ? -(0.1 + Math.random() * config.maxDivergence)
              : 0,
            speed: config.baseSpeed * (0.85 + Math.random() * 0.3),
            phase: Math.random(),
            opacity: isDivergent ? 0.95 : 0.25 + Math.random() * 0.2,
            charSet: isDivergent ? CHARS.rising : CHARS.flat,
            charWidth,
          });
        }

        // Sort so divergent streams draw on top
        state.streams.sort((a, b) => Math.abs(a.divergence) - Math.abs(b.divergence));
      }

      // Setup canvas with DPI scaling
      function setupCanvas() {
        const containerRect = (container as HTMLElement).getBoundingClientRect();
        const containerStyles = getComputedStyle(container as Element);
        const overflowTop = parseFloat(containerStyles.getPropertyValue('--overflow-top')) || 80;
        const dpr = window.devicePixelRatio || 1;

        const width = containerRect.width;
        const height = containerRect.height + overflowTop;

        // Scale font size based on container width
        state.fontSize = Math.max(12, Math.min(16, containerRect.width / 60));

        state.width = width;
        state.height = height;
        state.containerHeight = containerRect.height;
        state.overflowTop = overflowTop;
        state.dpr = dpr;

        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);

        createStreams();
      }

      function easeOutCubic(t: number): number {
        return 1 - Math.pow(1 - t, 3);
      }

      // Edge fade
      function getEdgeFade(x: number): number {
        const fadeWidth = state.width * config.edgeFade;
        if (x < fadeWidth) return Math.max(0, x / fadeWidth);
        if (x > state.width - fadeWidth) return Math.max(0, (state.width - x) / fadeWidth);
        return 1;
      }

      // Get color based on divergence progress
      function getColor(divergeRatio: number, alpha: number): string {
        // Base: warm orange, shifts toward gold as it rises
        const l = 68 + 14 * divergeRatio;
        const c = 0.14 + 0.03 * divergeRatio;
        const h = 35 + 25 * divergeRatio;
        return `oklch(${l}% ${c} ${h} / ${alpha})`;
      }

      // Draw a single stream of ASCII characters
      function drawStream(stream: Stream, entranceProgress: number) {
        const { width, height, overflowTop, containerHeight, fontSize } = state;
        const centerY = overflowTop + containerHeight / 2;

        // Calculate flow progress
        const adjustedTime = state.time * stream.speed;
        const flowProgress = ((adjustedTime / config.cycleDuration) + stream.phase) % 1;

        // Calculate the position of the head character
        const totalTravel = width + config.trailLength * stream.charWidth;
        const headX = -config.trailLength * stream.charWidth * 0.3 + flowProgress * totalTravel;

        // Don't draw if completely off screen
        if (headX < -stream.charWidth * 2 || headX - config.trailLength * stream.charWidth > width) return;

        const isDivergent = stream.divergence !== 0;

        // Set up font
        ctx.font = `${fontSize}px 'Geist Mono', 'SF Mono', Consolas, monospace`;
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';

        // Draw each character in the trail
        for (let i = 0; i < config.trailLength; i++) {
          const charX = headX - i * stream.charWidth;

          // Skip if off screen
          if (charX < -stream.charWidth || charX > width + stream.charWidth) continue;

          // Calculate Y position with divergence
          const canvasProgress = Math.max(0, Math.min(1, charX / width));
          const divergeAmount = stream.divergence * Math.pow(canvasProgress, 2.2) * height;
          const charY = centerY + stream.baseY + divergeAmount;

          // Calculate opacity: fade at tail, solid at head
          const trailProgress = i / config.trailLength;
          let charOpacity = stream.opacity * entranceProgress;

          // Tail fade - exponential falloff
          if (trailProgress > 0.3) {
            charOpacity *= Math.pow(1 - (trailProgress - 0.3) / 0.7, 1.5);
          }

          // Edge fade
          charOpacity *= getEdgeFade(charX);

          if (charOpacity < 0.02) continue;

          // Select character
          let char: string;
          if (i === 0 && isDivergent) {
            // Head character for divergent streams
            char = CHARS.head[Math.floor(state.time / 150) % CHARS.head.length];
          } else if (isDivergent && canvasProgress > 0.3) {
            // Rising characters when diverging
            char = stream.charSet[Math.floor((charX + state.time * 0.02) / 30) % stream.charSet.length];
          } else if (trailProgress > 0.85) {
            // Fade characters at tail
            char = CHARS.fade[Math.floor(trailProgress * CHARS.fade.length) % CHARS.fade.length];
          } else {
            // Regular flat characters
            char = CHARS.flat[Math.floor((charX + i * 7) / 20) % CHARS.flat.length];
          }

          // Color: divergent lines shift color as they rise
          const divergeRatio = isDivergent ? canvasProgress : 0;
          ctx.fillStyle = getColor(divergeRatio, charOpacity);

          // Draw character
          ctx.fillText(char, charX, charY);
        }

        // Draw a subtle glow behind the head for divergent streams
        if (isDivergent && headX > 0 && headX < width) {
          const headCanvasProgress = Math.max(0, Math.min(1, headX / width));
          const headDiverge = stream.divergence * Math.pow(headCanvasProgress, 2.2) * height;
          const headY = centerY + stream.baseY + headDiverge;
          const headOpacity = stream.opacity * entranceProgress * getEdgeFade(headX);

          // Glow
          ctx.beginPath();
          ctx.arc(headX, headY, fontSize * 0.8, 0, Math.PI * 2);
          ctx.fillStyle = getColor(1, headOpacity * 0.15);
          ctx.fill();
        }
      }

      function animate(timestamp: number) {
        if (!state.isRunning) return;

        if (!state.hasStarted) {
          state.startTime = timestamp;
          state.hasStarted = true;
        }

        state.time = timestamp - state.startTime;
        const entranceProgress = Math.min(1, easeOutCubic(state.time / config.entranceDuration));

        // Clear with slight trail effect for subtle motion blur
        ctx.fillStyle = 'oklch(14% 0.012 50)'; // Match background
        ctx.fillRect(0, 0, state.width, state.height);

        // Draw all streams
        state.streams.forEach((stream) => {
          drawStream(stream, entranceProgress);
        });

        state.animationId = requestAnimationFrame(animate);
      }

      function start() {
        if (state.isRunning) return;
        state.isRunning = true;
        state.hasStarted = false;
        state.animationId = requestAnimationFrame(animate);
      }

      function pause() {
        state.isRunning = false;
        cancelAnimationFrame(state.animationId);
      }

      function handleVisibility() {
        if (document.hidden) {
          pause();
        } else if (container.hasAttribute('data-visible')) {
          start();
        }
      }

      document.addEventListener('visibilitychange', handleVisibility);

      let resizeTimeout: ReturnType<typeof setTimeout>;
      const resizeObserver = new ResizeObserver(() => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(setupCanvas, 100);
      });
      resizeObserver.observe(container);

      const intersectionObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              container.setAttribute('data-visible', 'true');
              start();
            } else {
              container.removeAttribute('data-visible');
              pause();
            }
          });
        },
        { threshold: 0.1 }
      );
      intersectionObserver.observe(container);

      setupCanvas();

      (container as HTMLElement & { destroy?: () => void }).destroy = () => {
        pause();
        clearTimeout(resizeTimeout);
        resizeObserver.disconnect();
        intersectionObserver.disconnect();
        document.removeEventListener('visibilitychange', handleVisibility);
      };
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initDivergingPaths);
  } else {
    initDivergingPaths();
  }

  document.addEventListener('astro:page-load', initDivergingPaths);
</script>

<style>
  .diverging-paths {
    --overflow-top: 90px;
    position: relative;
    width: 100%;
    height: 90px;
    overflow: visible;
  }

  @media (min-width: 768px) {
    .diverging-paths {
      --overflow-top: 120px;
      height: 110px;
    }
  }

  @media (min-width: 1024px) {
    .diverging-paths {
      --overflow-top: 150px;
      height: 130px;
    }
  }

  @media (min-width: 1280px) {
    .diverging-paths {
      --overflow-top: 180px;
      height: 150px;
    }
  }

  .diverging-paths__canvas {
    display: block;
    position: absolute;
    left: 0;
    width: 100%;
    top: calc(-1 * var(--overflow-top));
    height: calc(100% + var(--overflow-top));
    pointer-events: none;
  }

  @media (prefers-reduced-motion: reduce) {
    .diverging-paths__canvas {
      opacity: 0.6;
    }
  }
</style>
