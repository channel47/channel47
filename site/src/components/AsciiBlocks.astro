---
/**
 * AsciiBlocks Component
 *
 * A dense field of ASCII block characters with visible wave interference.
 * Waves directly control character density and brightness.
 * Diverging paths visualize "same tools, different outcomes" —
 * channel pairs spawn together then split: one rises as signal, one fades as noise.
 *
 * The effect: flowing patterns of density that shift and morph,
 * with periodic divergences showing paths separating.
 */

interface Props {
  class?: string;
}

const { class: className } = Astro.props;
const canvasId = `ascii-blocks-${Math.random().toString(36).substr(2, 9)}`;
---

<div
  class={`ascii-blocks ${className || ''}`.trim()}
  data-ascii-blocks
>
  <canvas id={canvasId} class="ascii-blocks__canvas" aria-hidden="true"></canvas>
</div>

<script>
  // Block characters from sparse to dense
  const BLOCKS = ['·', '░', '▒', '▓', '█'];

  interface Cell {
    x: number;
    y: number;
    col: number;
    row: number;
    noisePhase: number;
    hue: number;
  }

  // Diverging paths: two channels spawn together, then split
  // One becomes signal (brightens), one becomes noise (fades)
  interface Divergence {
    originX: number;
    originY: number;
    startTime: number;
    // Direction angles for each path (radians)
    signalAngle: number;
    noiseAngle: number;
    // How fast the paths travel
    speed: number;
    // Path width
    width: number;
  }

  function initAsciiBlocks() {
    const containers = document.querySelectorAll('[data-ascii-blocks]');

    containers.forEach((container) => {
      if (container.hasAttribute('data-initialized')) return;
      container.setAttribute('data-initialized', 'true');

      const canvas = container.querySelector('canvas') as HTMLCanvasElement;
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      // State
      let cells: Cell[] = [];
      let divergences: Divergence[] = [];
      let width = 0;
      let height = 0;
      let cols = 0;
      let rows = 0;
      let cellSize = 16;
      let animationId = 0;
      let isRunning = false;
      let startTime = 0;
      let lastDivergenceTime = 0;

      const config = {
        entranceDuration: 1600,
        divergenceInterval: 5000,    // Time between divergence spawns
        divergenceSpeed: 0.08,       // How fast paths travel
        divergenceLifetime: 4500,    // How long before cleanup
        pathWidth: 80,               // Width of each path channel
        divergenceAngle: 0.35,       // How much paths diverge (radians)
        baseOpacity: 0.25,
        peakOpacity: 0.95,
      };

      // Two dominant waves that create clear interference bands
      function getWaveValue(x: number, y: number, time: number): number {
        // Wave 1: Horizontal sweep (primary)
        const wave1 = Math.sin(x * 0.012 + time * 0.0008);

        // Wave 2: Diagonal sweep (creates interference)
        const wave2 = Math.sin((x * 0.8 + y * 0.6) * 0.01 + time * 0.0006);

        // Wave 3: Slow vertical undulation
        const wave3 = Math.sin(y * 0.015 + time * 0.0003) * 0.4;

        // Combine with interference (waves can reinforce or cancel)
        const combined = (wave1 + wave2 + wave3) / 2.4;

        // Map from [-1, 1] to [0, 1]
        return (combined + 1) / 2;
      }

      // Divergence: returns { signal, noise } values for a point
      // Signal path brightens, noise path dims
      function getDivergenceValue(x: number, y: number, time: number): { signal: number; noise: number } {
        let signal = 0;
        let noise = 0;

        for (const div of divergences) {
          const elapsed = time - div.startTime;
          const travelDist = elapsed * div.speed;

          // Calculate position along each path
          // Signal path
          const signalHeadX = div.originX + Math.cos(div.signalAngle) * travelDist;
          const signalHeadY = div.originY + Math.sin(div.signalAngle) * travelDist;

          // Noise path
          const noiseHeadX = div.originX + Math.cos(div.noiseAngle) * travelDist;
          const noiseHeadY = div.originY + Math.sin(div.noiseAngle) * travelDist;

          // For each path, calculate influence based on:
          // 1. Distance from the path line (perpendicular distance)
          // 2. Position along the path (should be behind the "head")

          // Signal path influence
          const signalInfluence = getPathInfluence(
            x, y,
            div.originX, div.originY,
            signalHeadX, signalHeadY,
            div.width,
            elapsed,
            config.divergenceLifetime
          );

          // Noise path influence
          const noiseInfluence = getPathInfluence(
            x, y,
            div.originX, div.originY,
            noiseHeadX, noiseHeadY,
            div.width,
            elapsed,
            config.divergenceLifetime
          );

          signal = Math.max(signal, signalInfluence);
          noise = Math.max(noise, noiseInfluence);
        }

        return { signal, noise };
      }

      // Calculate how much a point is influenced by a path
      function getPathInfluence(
        px: number, py: number,           // Point to test
        originX: number, originY: number, // Path origin
        headX: number, headY: number,     // Current path head position
        pathWidth: number,
        elapsed: number,
        lifetime: number
      ): number {
        // Vector from origin to head
        const pathDx = headX - originX;
        const pathDy = headY - originY;
        const pathLength = Math.sqrt(pathDx * pathDx + pathDy * pathDy);

        if (pathLength < 1) return 0;

        // Vector from origin to point
        const pointDx = px - originX;
        const pointDy = py - originY;

        // Project point onto path line (dot product)
        const projection = (pointDx * pathDx + pointDy * pathDy) / pathLength;

        // Point must be between origin and head (with some trail behind head)
        const trailLength = pathLength * 0.7; // Trail extends 70% back from head
        const headPosition = pathLength;
        const trailStart = Math.max(0, headPosition - trailLength);

        if (projection < trailStart || projection > headPosition + 20) return 0;

        // Perpendicular distance from path line
        const perpDist = Math.abs((-pathDy * pointDx + pathDx * pointDy) / pathLength);

        if (perpDist > pathWidth) return 0;

        // Intensity based on distance from path center
        const widthFalloff = 1 - (perpDist / pathWidth);

        // Intensity based on position along path (brighter at head)
        const positionInTrail = (projection - trailStart) / trailLength;
        const headProximity = Math.pow(positionInTrail, 0.6);

        // Overall fade over lifetime
        const lifetimeFade = 1 - Math.pow(elapsed / lifetime, 1.5);

        // Combine factors
        return widthFalloff * widthFalloff * headProximity * lifetimeFade;
      }

      function spawnDivergence(time: number) {
        // Spawn from edges or center area
        const spawnFromLeft = Math.random() > 0.5;
        let originX: number, originY: number, baseAngle: number;

        if (spawnFromLeft) {
          // Spawn from left side, moving right-ish
          originX = width * (0.05 + Math.random() * 0.15);
          originY = height * (0.2 + Math.random() * 0.6);
          baseAngle = -0.3 + Math.random() * 0.6; // Roughly rightward
        } else {
          // Spawn from center-left area
          originX = width * (0.2 + Math.random() * 0.3);
          originY = height * (0.15 + Math.random() * 0.7);
          baseAngle = -0.5 + Math.random() * 1.0;
        }

        // Two paths diverge from the same origin
        // One goes slightly up, one slightly down (or variations)
        const divergeAmount = config.divergenceAngle * (0.8 + Math.random() * 0.4);

        divergences.push({
          originX,
          originY,
          startTime: time,
          signalAngle: baseAngle - divergeAmount,
          noiseAngle: baseAngle + divergeAmount,
          speed: config.divergenceSpeed * (0.85 + Math.random() * 0.3),
          width: config.pathWidth * (0.8 + Math.random() * 0.4),
        });

        // Clean old divergences
        divergences = divergences.filter(d => time - d.startTime < config.divergenceLifetime);
      }

      function setupCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = Math.min(window.devicePixelRatio || 1, 2);

        width = rect.width;
        height = rect.height;

        // Responsive cell size
        if (rect.width < 480) {
          cellSize = 12;
        } else if (rect.width < 768) {
          cellSize = 14;
        } else if (rect.width < 1024) {
          cellSize = 16;
        } else {
          cellSize = 18;
        }

        cols = Math.ceil(rect.width / cellSize) + 1;
        rows = Math.ceil(rect.height / cellSize) + 1;

        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        canvas.style.width = `${rect.width}px`;
        canvas.style.height = `${rect.height}px`;

        ctx.scale(dpr, dpr);

        // Create cells
        cells = [];
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            cells.push({
              x: col * cellSize,
              y: row * cellSize,
              col,
              row,
              noisePhase: Math.random() * Math.PI * 2,
              hue: 28 + Math.random() * 14,
            });
          }
        }

        divergences = [];
      }

      function easeOutExpo(t: number): number {
        return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
      }

      function animate(timestamp: number) {
        if (!isRunning) return;

        if (startTime === 0) {
          startTime = timestamp;
          lastDivergenceTime = timestamp;
        }

        const time = timestamp - startTime;
        const entranceProgress = Math.min(1, easeOutExpo(time / config.entranceDuration));

        // Spawn divergences periodically
        if (time - lastDivergenceTime > config.divergenceInterval && time > 800) {
          spawnDivergence(time);
          lastDivergenceTime = time;
        }

        ctx.clearRect(0, 0, width, height);
        ctx.font = `${cellSize}px "Geist Mono", ui-monospace, monospace`;
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';

        for (const cell of cells) {
          const cx = cell.x + cellSize / 2;
          const cy = cell.y + cellSize / 2;

          // Get wave value (0-1) - this drives the base pattern
          const waveValue = getWaveValue(cx, cy, time);

          // Get divergence values - signal brightens, noise dims
          const { signal, noise } = getDivergenceValue(cx, cy, time);

          // Small per-cell shimmer
          const shimmer = Math.sin(time * 0.002 + cell.noisePhase) * 0.08;

          // Combined intensity:
          // - Base wave pattern
          // - Signal path boosts brightness (the winning path)
          // - Noise path reduces brightness (the fading path)
          const divergenceEffect = signal * 0.8 - noise * 0.4;
          const intensity = Math.max(0, Math.min(1, waveValue + shimmer + divergenceEffect));

          // Entrance animation (sweep from left)
          const entranceDelay = (cell.x / width) * 0.4;
          const cellEntrance = Math.max(0, Math.min(1,
            (entranceProgress - entranceDelay) / (1 - entranceDelay * 0.5)
          ));

          if (cellEntrance <= 0) continue;

          // Character based on intensity
          // Map intensity 0-1 to character index
          const charIndex = Math.min(BLOCKS.length - 1, Math.floor(intensity * BLOCKS.length));
          const char = BLOCKS[charIndex];

          // Opacity: wave creates visible variation
          // Signal path increases opacity, noise path decreases
          const baseOpacity = config.baseOpacity + (config.peakOpacity - config.baseOpacity) * (waveValue * 0.6);
          const opacityMod = signal * 0.5 - noise * 0.15;
          const finalOpacity = Math.max(0.08, Math.min(1, baseOpacity + opacityMod)) * cellEntrance;

          // Color: signal path gets warmer/brighter, noise path cooler/dimmer
          const saturation = 0.02 + intensity * 0.14 + signal * 0.08;
          const lightness = 30 + intensity * 50 + signal * 20 - noise * 15;
          const hue = cell.hue + signal * 12 - noise * 8;

          ctx.fillStyle = `oklch(${lightness}% ${saturation} ${hue} / ${finalOpacity})`;
          ctx.fillText(char, cell.x, cell.y);

          // Extra glow layer for strong signal paths
          if (signal > 0.5) {
            const glowOpacity = (signal - 0.5) * 0.6 * cellEntrance;
            ctx.fillStyle = `oklch(85% 0.16 38 / ${glowOpacity})`;
            ctx.fillText(char, cell.x, cell.y);
          }
        }

        animationId = requestAnimationFrame(animate);
      }

      function start() {
        if (isRunning) return;
        isRunning = true;
        startTime = 0;
        animationId = requestAnimationFrame(animate);
      }

      function pause() {
        isRunning = false;
        cancelAnimationFrame(animationId);
      }

      function handleVisibility() {
        if (document.hidden) {
          pause();
        } else if (container.hasAttribute('data-visible')) {
          start();
        }
      }

      document.addEventListener('visibilitychange', handleVisibility);

      const resizeObserver = new ResizeObserver(() => {
        setupCanvas();
      });
      resizeObserver.observe(container);

      const intersectionObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              container.setAttribute('data-visible', 'true');
              start();
            } else {
              container.removeAttribute('data-visible');
              pause();
            }
          });
        },
        { threshold: 0.1 }
      );
      intersectionObserver.observe(container);

      // Wait for font to load before starting to avoid visual artifacts
      async function waitForFont() {
        try {
          await document.fonts.load('16px "Geist Mono"');
        } catch {
          // Font API not supported or font not found, proceed anyway
        }
        setupCanvas();
      }

      waitForFont();

      (container as HTMLElement & { destroy?: () => void }).destroy = () => {
        pause();
        resizeObserver.disconnect();
        intersectionObserver.disconnect();
        document.removeEventListener('visibilitychange', handleVisibility);
      };
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAsciiBlocks);
  } else {
    initAsciiBlocks();
  }

  document.addEventListener('astro:page-load', initAsciiBlocks);
</script>

<style>
  .ascii-blocks {
    position: relative;
    width: 100%;
    /* Generous height on mobile for visual impact */
    height: 180px;
    overflow: hidden;

    /* Softer fade on mobile for more breathing room */
    mask-image:
      linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%),
      linear-gradient(to right, transparent 0%, black 6%, black 94%, transparent 100%);
    mask-composite: intersect;
    -webkit-mask-image:
      linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%),
      linear-gradient(to right, transparent 0%, black 6%, black 94%, transparent 100%);
    -webkit-mask-composite: source-in;
  }

  @media (min-width: 375px) {
    .ascii-blocks {
      height: 200px;
    }
  }

  @media (min-width: 480px) {
    .ascii-blocks {
      height: 240px;
      /* Tighter fade on larger screens */
      mask-image:
        linear-gradient(to bottom, transparent 0%, black 12%, black 88%, transparent 100%),
        linear-gradient(to right, transparent 0%, black 4%, black 96%, transparent 100%);
      -webkit-mask-image:
        linear-gradient(to bottom, transparent 0%, black 12%, black 88%, transparent 100%),
        linear-gradient(to right, transparent 0%, black 4%, black 96%, transparent 100%);
    }
  }

  @media (min-width: 768px) {
    .ascii-blocks {
      height: 300px;
    }
  }

  @media (min-width: 1024px) {
    .ascii-blocks {
      height: 360px;
    }
  }

  @media (min-width: 1280px) {
    .ascii-blocks {
      height: 420px;
    }
  }

  .ascii-blocks__canvas {
    display: block;
    width: 100%;
    height: 100%;
  }

  @media (prefers-reduced-motion: reduce) {
    .ascii-blocks__canvas {
      opacity: 0.35;
    }
  }
</style>
