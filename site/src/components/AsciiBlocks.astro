---
/**
 * AsciiBlocks Component
 *
 * A dense field of ASCII block characters with visible wave interference.
 * Waves directly control character density and brightness.
 * Emergence waves sweep through, temporarily revealing signal from noise —
 * like insight surfacing, or tuning into a frequency.
 *
 * The effect: flowing patterns of density that shift and morph,
 * with periodic waves of clarity sweeping through.
 */

interface Props {
  class?: string;
}

const { class: className } = Astro.props;
const canvasId = `ascii-blocks-${Math.random().toString(36).substr(2, 9)}`;
---

<div
  class={`ascii-blocks ${className || ''}`.trim()}
  data-ascii-blocks
>
  <canvas id={canvasId} class="ascii-blocks__canvas" aria-hidden="true"></canvas>
</div>

<script>
  // Block characters from sparse to dense
  const BLOCKS = ['·', '░', '▒', '▓', '█'];

  interface Cell {
    x: number;
    y: number;
    col: number;
    row: number;
    noisePhase: number;
    hue: number;
  }

  // Emergence wave: sweeps across the field, temporarily revealing signal
  // Like insight surfacing or tuning into a frequency
  interface EmergenceWave {
    startTime: number;
    // Direction the wave travels (angle in radians, 0 = right)
    angle: number;
    // Starting offset (where the wave front begins)
    offset: number;
    // Wave characteristics
    speed: number;
    width: number;        // How wide the "revelation" band is
    strength: number;
  }

  function initAsciiBlocks() {
    const containers = document.querySelectorAll('[data-ascii-blocks]');

    containers.forEach((container) => {
      if (container.hasAttribute('data-initialized')) return;
      container.setAttribute('data-initialized', 'true');

      const canvas = container.querySelector('canvas') as HTMLCanvasElement;
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      // State
      let cells: Cell[] = [];
      let waves: EmergenceWave[] = [];
      let width = 0;
      let height = 0;
      let cols = 0;
      let rows = 0;
      let cellSize = 16;
      let animationId = 0;
      let isRunning = false;
      let startTime = 0;
      let lastWaveTime = 0;

      const config = {
        entranceDuration: 1600,
        waveInterval: 4500,       // Time between wave spawns
        waveSpeed: 0.12,          // How fast waves travel
        waveWidth: 180,           // Width of the revelation band
        waveLifetime: 5000,       // How long before cleanup
        baseOpacity: 0.25,
        peakOpacity: 0.95,
      };

      // Two dominant waves that create clear interference bands
      function getWaveValue(x: number, y: number, time: number): number {
        // Wave 1: Horizontal sweep (primary)
        const wave1 = Math.sin(x * 0.012 + time * 0.0008);

        // Wave 2: Diagonal sweep (creates interference)
        const wave2 = Math.sin((x * 0.8 + y * 0.6) * 0.01 + time * 0.0006);

        // Wave 3: Slow vertical undulation
        const wave3 = Math.sin(y * 0.015 + time * 0.0003) * 0.4;

        // Combine with interference (waves can reinforce or cancel)
        const combined = (wave1 + wave2 + wave3) / 2.4;

        // Map from [-1, 1] to [0, 1]
        return (combined + 1) / 2;
      }

      // Emergence wave: a plane of revelation sweeping through
      // Returns intensity (0-1) of the wave effect at this point
      function getEmergenceValue(x: number, y: number, time: number): number {
        let total = 0;

        for (const wave of waves) {
          const elapsed = time - wave.startTime;

          // Project point onto wave direction to get distance along wave travel
          // Wave travels in direction of angle, so we measure perpendicular distance
          const cosA = Math.cos(wave.angle);
          const sinA = Math.sin(wave.angle);

          // Distance along the wave's travel direction
          const travelDist = x * cosA + y * sinA;

          // Current position of wave front
          const waveFront = wave.offset + elapsed * wave.speed;

          // Distance from wave front (negative = wave hasn't reached yet)
          const distFromFront = travelDist - waveFront;

          // Wave has a leading edge, peak, and trailing fade
          // Shape: ramps up quickly, holds briefly, fades slowly
          const waveWidth = wave.width;

          if (distFromFront > waveWidth * 0.3 || distFromFront < -waveWidth) {
            continue; // Outside wave influence
          }

          let intensity: number;

          if (distFromFront > 0) {
            // Leading edge: sharp rise (wave approaching)
            intensity = 1 - (distFromFront / (waveWidth * 0.3));
          } else if (distFromFront > -waveWidth * 0.2) {
            // Peak zone: full intensity
            intensity = 1;
          } else {
            // Trailing fade: gradual falloff
            const fadeProgress = (-distFromFront - waveWidth * 0.2) / (waveWidth * 0.8);
            intensity = 1 - Math.pow(fadeProgress, 0.7);
          }

          // Overall fade over lifetime
          const lifetimeFade = 1 - Math.pow(elapsed / config.waveLifetime, 2);

          total = Math.max(total, intensity * lifetimeFade * wave.strength);
        }

        return Math.min(1, total);
      }

      function spawnWave(time: number) {
        // Diagonal angle for interesting sweep patterns
        // Vary between roughly left-to-right and top-left-to-bottom-right
        const angleOptions = [
          0.15 + Math.random() * 0.25,   // Slight diagonal down-right
          -0.15 - Math.random() * 0.2,   // Slight diagonal up-right
          0.4 + Math.random() * 0.3,     // Steeper diagonal
        ];
        const angle = angleOptions[Math.floor(Math.random() * angleOptions.length)];

        // Start from off-screen left
        const maxDim = Math.max(width, height);
        const offset = -maxDim * 0.3 - Math.random() * 100;

        waves.push({
          startTime: time,
          angle,
          offset,
          speed: config.waveSpeed * (0.85 + Math.random() * 0.3),
          width: config.waveWidth * (0.8 + Math.random() * 0.4),
          strength: 0.7 + Math.random() * 0.3,
        });

        // Clean old waves
        waves = waves.filter(w => time - w.startTime < config.waveLifetime);
      }

      function setupCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = Math.min(window.devicePixelRatio || 1, 2);

        width = rect.width;
        height = rect.height;

        // Responsive cell size
        if (rect.width < 480) {
          cellSize = 12;
        } else if (rect.width < 768) {
          cellSize = 14;
        } else if (rect.width < 1024) {
          cellSize = 16;
        } else {
          cellSize = 18;
        }

        cols = Math.ceil(rect.width / cellSize) + 1;
        rows = Math.ceil(rect.height / cellSize) + 1;

        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        canvas.style.width = `${rect.width}px`;
        canvas.style.height = `${rect.height}px`;

        ctx.scale(dpr, dpr);

        // Create cells
        cells = [];
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            cells.push({
              x: col * cellSize,
              y: row * cellSize,
              col,
              row,
              noisePhase: Math.random() * Math.PI * 2,
              hue: 28 + Math.random() * 14,
            });
          }
        }

        waves = [];
      }

      function easeOutExpo(t: number): number {
        return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
      }

      function animate(timestamp: number) {
        if (!isRunning) return;

        if (startTime === 0) {
          startTime = timestamp;
          lastWaveTime = timestamp;
        }

        const time = timestamp - startTime;
        const entranceProgress = Math.min(1, easeOutExpo(time / config.entranceDuration));

        // Spawn emergence waves periodically
        if (time - lastWaveTime > config.waveInterval && time > 800) {
          spawnWave(time);
          lastWaveTime = time;
        }

        ctx.clearRect(0, 0, width, height);
        ctx.font = `${cellSize}px "Geist Mono", ui-monospace, monospace`;
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';

        for (const cell of cells) {
          const cx = cell.x + cellSize / 2;
          const cy = cell.y + cellSize / 2;

          // Get ambient wave value (0-1) - base pattern
          const ambientValue = getWaveValue(cx, cy, time);

          // Get emergence wave value (0-1) - revelation sweeping through
          const emergenceValue = getEmergenceValue(cx, cy, time);

          // Small per-cell shimmer
          const shimmer = Math.sin(time * 0.002 + cell.noisePhase) * 0.08;

          // Combined intensity: emergence wave boosts and clarifies
          const intensity = Math.min(1, ambientValue + shimmer + emergenceValue * 0.6);

          // Entrance animation (sweep from left)
          const entranceDelay = (cell.x / width) * 0.4;
          const cellEntrance = Math.max(0, Math.min(1,
            (entranceProgress - entranceDelay) / (1 - entranceDelay * 0.5)
          ));

          if (cellEntrance <= 0) continue;

          // Character based on intensity
          const charIndex = Math.min(BLOCKS.length - 1, Math.floor(intensity * BLOCKS.length));
          const char = BLOCKS[charIndex];

          // Opacity: emergence wave reveals and clarifies
          const baseOpacity = config.baseOpacity + (config.peakOpacity - config.baseOpacity) * (ambientValue * 0.6);
          const finalOpacity = Math.min(1, baseOpacity + emergenceValue * 0.55) * cellEntrance;

          // Color: emergence wave brings warmth and brightness
          const saturation = 0.02 + intensity * 0.14 + emergenceValue * 0.06;
          const lightness = 30 + intensity * 50 + emergenceValue * 15;
          const hue = cell.hue + emergenceValue * 10;

          ctx.fillStyle = `oklch(${lightness}% ${saturation} ${hue} / ${finalOpacity})`;
          ctx.fillText(char, cell.x, cell.y);

          // Subtle glow layer for strong emergence zones
          if (emergenceValue > 0.6) {
            const glowOpacity = (emergenceValue - 0.6) * 0.4 * cellEntrance;
            ctx.fillStyle = `oklch(82% 0.14 36 / ${glowOpacity})`;
            ctx.fillText(char, cell.x, cell.y);
          }
        }

        animationId = requestAnimationFrame(animate);
      }

      function start() {
        if (isRunning) return;
        isRunning = true;
        startTime = 0;
        animationId = requestAnimationFrame(animate);
      }

      function pause() {
        isRunning = false;
        cancelAnimationFrame(animationId);
      }

      function handleVisibility() {
        if (document.hidden) {
          pause();
        } else if (container.hasAttribute('data-visible')) {
          start();
        }
      }

      document.addEventListener('visibilitychange', handleVisibility);

      const resizeObserver = new ResizeObserver(() => {
        setupCanvas();
      });
      resizeObserver.observe(container);

      const intersectionObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              container.setAttribute('data-visible', 'true');
              start();
            } else {
              container.removeAttribute('data-visible');
              pause();
            }
          });
        },
        { threshold: 0.1 }
      );
      intersectionObserver.observe(container);

      // Wait for font to load before starting to avoid visual artifacts
      async function waitForFont() {
        try {
          await document.fonts.load('16px "Geist Mono"');
        } catch {
          // Font API not supported or font not found, proceed anyway
        }
        setupCanvas();
      }

      waitForFont();

      (container as HTMLElement & { destroy?: () => void }).destroy = () => {
        pause();
        resizeObserver.disconnect();
        intersectionObserver.disconnect();
        document.removeEventListener('visibilitychange', handleVisibility);
      };
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAsciiBlocks);
  } else {
    initAsciiBlocks();
  }

  document.addEventListener('astro:page-load', initAsciiBlocks);
</script>

<style>
  .ascii-blocks {
    position: relative;
    width: 100%;
    /* Generous height on mobile for visual impact */
    height: 180px;
    overflow: hidden;

    /* Softer fade on mobile for more breathing room */
    mask-image:
      linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%),
      linear-gradient(to right, transparent 0%, black 6%, black 94%, transparent 100%);
    mask-composite: intersect;
    -webkit-mask-image:
      linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%),
      linear-gradient(to right, transparent 0%, black 6%, black 94%, transparent 100%);
    -webkit-mask-composite: source-in;
  }

  @media (min-width: 375px) {
    .ascii-blocks {
      height: 200px;
    }
  }

  @media (min-width: 480px) {
    .ascii-blocks {
      height: 240px;
      /* Tighter fade on larger screens */
      mask-image:
        linear-gradient(to bottom, transparent 0%, black 12%, black 88%, transparent 100%),
        linear-gradient(to right, transparent 0%, black 4%, black 96%, transparent 100%);
      -webkit-mask-image:
        linear-gradient(to bottom, transparent 0%, black 12%, black 88%, transparent 100%),
        linear-gradient(to right, transparent 0%, black 4%, black 96%, transparent 100%);
    }
  }

  @media (min-width: 768px) {
    .ascii-blocks {
      height: 300px;
    }
  }

  @media (min-width: 1024px) {
    .ascii-blocks {
      height: 360px;
    }
  }

  @media (min-width: 1280px) {
    .ascii-blocks {
      height: 420px;
    }
  }

  .ascii-blocks__canvas {
    display: block;
    width: 100%;
    height: 100%;
  }

  @media (prefers-reduced-motion: reduce) {
    .ascii-blocks__canvas {
      opacity: 0.35;
    }
  }
</style>
