---
/**
 * AsciiBlocks Component
 *
 * A dense field of ASCII block characters with visible wave interference.
 * Gravitational attractors periodically form, pulling characters inward
 * to create density wells — like watching a thought crystallize or
 * knowledge accumulating. Characters visibly shift toward the attractor,
 * cluster at peak intensity, then release outward.
 *
 * The effect: flowing ambient patterns punctuated by moments of
 * coalescence and release.
 */

interface Props {
  class?: string;
}

const { class: className } = Astro.props;
const canvasId = `ascii-blocks-${Math.random().toString(36).substr(2, 9)}`;
---

<div
  class={`ascii-blocks ${className || ''}`.trim()}
  data-ascii-blocks
>
  <canvas id={canvasId} class="ascii-blocks__canvas" aria-hidden="true"></canvas>
</div>

<script>
  // Block characters from sparse to dense
  const BLOCKS = ['·', '░', '▒', '▓', '█'];

  interface Cell {
    x: number;
    y: number;
    col: number;
    row: number;
    noisePhase: number;
    hue: number;
  }

  // Gravitational attractor: pulls characters toward it
  interface Attractor {
    x: number;
    y: number;
    startTime: number;
    strength: number;
    radius: number;
    // Lifecycle phases
    gatherDuration: number;   // Time to reach peak pull
    holdDuration: number;     // Time at peak
    releaseDuration: number;  // Time to release
  }

  function initAsciiBlocks() {
    const containers = document.querySelectorAll('[data-ascii-blocks]');

    containers.forEach((container) => {
      if (container.hasAttribute('data-initialized')) return;
      container.setAttribute('data-initialized', 'true');

      const canvas = container.querySelector('canvas') as HTMLCanvasElement;
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      // State
      let cells: Cell[] = [];
      let attractors: Attractor[] = [];
      let width = 0;
      let height = 0;
      let cols = 0;
      let rows = 0;
      let cellSize = 16;
      let animationId = 0;
      let isRunning = false;
      let startTime = 0;
      let lastAttractorTime = 0;

      const config = {
        entranceDuration: 1600,
        attractorInterval: 6000,      // Time between attractor spawns
        attractorRadius: 220,         // Influence radius
        maxPullStrength: 0.7,         // How much characters shift (0-1)
        gatherDuration: 1800,         // Gather phase
        holdDuration: 800,            // Hold at peak
        releaseDuration: 2000,        // Release phase
        baseOpacity: 0.25,
        peakOpacity: 0.95,
      };

      // Ambient wave interference for base movement
      function getWaveValue(x: number, y: number, time: number): number {
        const wave1 = Math.sin(x * 0.012 + time * 0.0008);
        const wave2 = Math.sin((x * 0.8 + y * 0.6) * 0.01 + time * 0.0006);
        const wave3 = Math.sin(y * 0.015 + time * 0.0003) * 0.4;
        const combined = (wave1 + wave2 + wave3) / 2.4;
        return (combined + 1) / 2;
      }

      // Easing functions for smooth animation
      function easeOutCubic(t: number): number {
        return 1 - Math.pow(1 - t, 3);
      }

      function easeInOutQuad(t: number): number {
        return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
      }

      function easeOutExpo(t: number): number {
        return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
      }

      // Calculate attractor influence on a point
      // Returns: { pull: 0-1 strength, dx: x offset, dy: y offset, phase: 'gather'|'hold'|'release'|'afterglow' }
      function getAttractorInfluence(
        x: number,
        y: number,
        time: number
      ): { pull: number; dx: number; dy: number; phase: string; glowIntensity: number } {
        let totalPull = 0;
        let totalDx = 0;
        let totalDy = 0;
        let maxGlow = 0;
        let dominantPhase = 'none';

        for (const attractor of attractors) {
          const elapsed = time - attractor.startTime;
          const totalDuration = attractor.gatherDuration + attractor.holdDuration + attractor.releaseDuration;

          // Distance from attractor center
          const dx = attractor.x - x;
          const dy = attractor.y - y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          // Skip if outside influence radius
          if (dist > attractor.radius * 1.5) continue;

          // Normalized distance (0 at center, 1 at edge)
          const normDist = Math.min(1, dist / attractor.radius);

          // Distance falloff - stronger pull near center
          const distanceFalloff = Math.pow(1 - normDist, 1.5);

          // Phase-based animation
          let phaseMultiplier = 0;
          let phase = 'none';
          let glowIntensity = 0;

          if (elapsed < attractor.gatherDuration) {
            // GATHER: Pull increases
            phase = 'gather';
            const progress = elapsed / attractor.gatherDuration;
            phaseMultiplier = easeOutCubic(progress);
            glowIntensity = progress * 0.3;
          } else if (elapsed < attractor.gatherDuration + attractor.holdDuration) {
            // HOLD: Maximum pull
            phase = 'hold';
            phaseMultiplier = 1;
            glowIntensity = 0.5;
          } else if (elapsed < totalDuration) {
            // RELEASE: Pull decreases, expansion
            phase = 'release';
            const releaseProgress = (elapsed - attractor.gatherDuration - attractor.holdDuration) / attractor.releaseDuration;
            phaseMultiplier = 1 - easeInOutQuad(releaseProgress);
            // During release, create subtle outward push
            glowIntensity = 0.8 * (1 - releaseProgress);
          } else if (elapsed < totalDuration + 800) {
            // AFTERGLOW: Subtle lingering energy
            phase = 'afterglow';
            const afterglowProgress = (elapsed - totalDuration) / 800;
            phaseMultiplier = 0;
            glowIntensity = 0.3 * (1 - afterglowProgress);
          }

          if (phaseMultiplier > 0 || glowIntensity > 0) {
            const pullStrength = attractor.strength * distanceFalloff * phaseMultiplier;

            // Calculate pull direction (toward attractor)
            if (dist > 0.1) {
              const pullDx = (dx / dist) * pullStrength * config.maxPullStrength * cellSize * 2;
              const pullDy = (dy / dist) * pullStrength * config.maxPullStrength * cellSize * 2;
              totalDx += pullDx;
              totalDy += pullDy;
            }

            totalPull = Math.max(totalPull, pullStrength);
            maxGlow = Math.max(maxGlow, glowIntensity * distanceFalloff);
            if (pullStrength > 0.1 || glowIntensity > 0.1) {
              dominantPhase = phase;
            }
          }
        }

        return {
          pull: Math.min(1, totalPull),
          dx: totalDx,
          dy: totalDy,
          phase: dominantPhase,
          glowIntensity: maxGlow
        };
      }

      function spawnAttractor(time: number) {
        // Rule of thirds positioning for visual interest
        const posOptions = [
          { x: width * 0.33, y: height * 0.4 },
          { x: width * 0.67, y: height * 0.35 },
          { x: width * 0.5, y: height * 0.5 },
          { x: width * 0.4, y: height * 0.6 },
          { x: width * 0.6, y: height * 0.45 },
        ];
        const pos = posOptions[Math.floor(Math.random() * posOptions.length)];

        attractors.push({
          x: pos.x + (Math.random() - 0.5) * 60,
          y: pos.y + (Math.random() - 0.5) * 40,
          startTime: time,
          strength: 0.8 + Math.random() * 0.2,
          radius: config.attractorRadius * (0.85 + Math.random() * 0.3),
          gatherDuration: config.gatherDuration * (0.9 + Math.random() * 0.2),
          holdDuration: config.holdDuration * (0.8 + Math.random() * 0.4),
          releaseDuration: config.releaseDuration * (0.9 + Math.random() * 0.2),
        });

        // Clean old attractors
        const maxLifetime = config.gatherDuration + config.holdDuration + config.releaseDuration + 1000;
        attractors = attractors.filter(a => time - a.startTime < maxLifetime);
      }

      function setupCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = Math.min(window.devicePixelRatio || 1, 2);

        width = rect.width;
        height = rect.height;

        // Responsive cell size
        if (rect.width < 480) {
          cellSize = 12;
        } else if (rect.width < 768) {
          cellSize = 14;
        } else if (rect.width < 1024) {
          cellSize = 16;
        } else {
          cellSize = 18;
        }

        cols = Math.ceil(rect.width / cellSize) + 1;
        rows = Math.ceil(rect.height / cellSize) + 1;

        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        canvas.style.width = `${rect.width}px`;
        canvas.style.height = `${rect.height}px`;

        ctx.scale(dpr, dpr);

        // Create cells
        cells = [];
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            cells.push({
              x: col * cellSize,
              y: row * cellSize,
              col,
              row,
              noisePhase: Math.random() * Math.PI * 2,
              hue: 28 + Math.random() * 14,
            });
          }
        }

        attractors = [];
      }

      function animate(timestamp: number) {
        if (!isRunning) return;

        if (startTime === 0) {
          startTime = timestamp;
          lastAttractorTime = timestamp;
        }

        const time = timestamp - startTime;
        const entranceProgress = Math.min(1, easeOutExpo(time / config.entranceDuration));

        // Spawn attractors periodically
        if (time - lastAttractorTime > config.attractorInterval && time > 1000) {
          spawnAttractor(time);
          lastAttractorTime = time;
        }

        ctx.clearRect(0, 0, width, height);
        ctx.font = `${cellSize}px "Geist Mono", ui-monospace, monospace`;
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';

        for (const cell of cells) {
          const cx = cell.x + cellSize / 2;
          const cy = cell.y + cellSize / 2;

          // Get attractor influence
          const influence = getAttractorInfluence(cx, cy, time);

          // Calculate render position (original + pull offset)
          const renderX = cell.x + influence.dx;
          const renderY = cell.y + influence.dy;

          // Get ambient wave value
          const waveValue = getWaveValue(cx, cy, time);

          // Small per-cell shimmer
          const shimmer = Math.sin(time * 0.002 + cell.noisePhase) * 0.08;

          // Combined intensity: pull creates density increase
          const pullBoost = influence.pull * 0.5;
          const intensity = Math.min(1, waveValue + shimmer + pullBoost);

          // Entrance animation (sweep from left)
          const entranceDelay = (cell.x / width) * 0.4;
          const cellEntrance = Math.max(0, Math.min(1,
            (entranceProgress - entranceDelay) / (1 - entranceDelay * 0.5)
          ));

          if (cellEntrance <= 0) continue;

          // Character based on intensity (denser when pulled)
          const charIndex = Math.min(BLOCKS.length - 1, Math.floor(intensity * BLOCKS.length));
          const char = BLOCKS[charIndex];

          // Opacity: increases when being pulled
          const baseOpacity = config.baseOpacity + (config.peakOpacity - config.baseOpacity) * (waveValue * 0.6);
          const pullOpacityBoost = influence.pull * 0.4 + influence.glowIntensity * 0.3;
          const finalOpacity = Math.min(1, baseOpacity + pullOpacityBoost) * cellEntrance;

          // Color: warmer and brighter when pulled
          const saturation = 0.02 + intensity * 0.14 + influence.pull * 0.1;
          const lightness = 30 + intensity * 50 + influence.pull * 20 + influence.glowIntensity * 15;
          const hue = cell.hue + influence.pull * 8;

          ctx.fillStyle = `oklch(${lightness}% ${saturation} ${hue} / ${finalOpacity})`;
          ctx.fillText(char, renderX, renderY);

          // Glow layer for peak moments
          if (influence.glowIntensity > 0.3) {
            const glowOpacity = (influence.glowIntensity - 0.3) * 0.5 * cellEntrance;
            ctx.fillStyle = `oklch(85% 0.18 38 / ${glowOpacity})`;
            ctx.fillText(char, renderX, renderY);
          }
        }

        animationId = requestAnimationFrame(animate);
      }

      function start() {
        if (isRunning) return;
        isRunning = true;
        startTime = 0;
        animationId = requestAnimationFrame(animate);
      }

      function pause() {
        isRunning = false;
        cancelAnimationFrame(animationId);
      }

      function handleVisibility() {
        if (document.hidden) {
          pause();
        } else if (container.hasAttribute('data-visible')) {
          start();
        }
      }

      document.addEventListener('visibilitychange', handleVisibility);

      const resizeObserver = new ResizeObserver(() => {
        setupCanvas();
      });
      resizeObserver.observe(container);

      const intersectionObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              container.setAttribute('data-visible', 'true');
              start();
            } else {
              container.removeAttribute('data-visible');
              pause();
            }
          });
        },
        { threshold: 0.1 }
      );
      intersectionObserver.observe(container);

      // Wait for font to load before starting to avoid visual artifacts
      async function waitForFont() {
        try {
          await document.fonts.load('16px "Geist Mono"');
        } catch {
          // Font API not supported or font not found, proceed anyway
        }
        setupCanvas();
      }

      waitForFont();

      (container as HTMLElement & { destroy?: () => void }).destroy = () => {
        pause();
        resizeObserver.disconnect();
        intersectionObserver.disconnect();
        document.removeEventListener('visibilitychange', handleVisibility);
      };
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAsciiBlocks);
  } else {
    initAsciiBlocks();
  }

  document.addEventListener('astro:page-load', initAsciiBlocks);
</script>

<style>
  .ascii-blocks {
    position: relative;
    width: 100%;
    /* Generous height on mobile for visual impact */
    height: 180px;
    overflow: hidden;

    /* Softer fade on mobile for more breathing room */
    mask-image:
      linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%),
      linear-gradient(to right, transparent 0%, black 6%, black 94%, transparent 100%);
    mask-composite: intersect;
    -webkit-mask-image:
      linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%),
      linear-gradient(to right, transparent 0%, black 6%, black 94%, transparent 100%);
    -webkit-mask-composite: source-in;
  }

  @media (min-width: 375px) {
    .ascii-blocks {
      height: 200px;
    }
  }

  @media (min-width: 480px) {
    .ascii-blocks {
      height: 240px;
      /* Tighter fade on larger screens */
      mask-image:
        linear-gradient(to bottom, transparent 0%, black 12%, black 88%, transparent 100%),
        linear-gradient(to right, transparent 0%, black 4%, black 96%, transparent 100%);
      -webkit-mask-image:
        linear-gradient(to bottom, transparent 0%, black 12%, black 88%, transparent 100%),
        linear-gradient(to right, transparent 0%, black 4%, black 96%, transparent 100%);
    }
  }

  @media (min-width: 768px) {
    .ascii-blocks {
      height: 300px;
    }
  }

  @media (min-width: 1024px) {
    .ascii-blocks {
      height: 360px;
    }
  }

  @media (min-width: 1280px) {
    .ascii-blocks {
      height: 420px;
    }
  }

  .ascii-blocks__canvas {
    display: block;
    width: 100%;
    height: 100%;
  }

  @media (prefers-reduced-motion: reduce) {
    .ascii-blocks__canvas {
      opacity: 0.35;
    }
  }
</style>
