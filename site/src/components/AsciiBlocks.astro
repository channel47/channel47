---
/**
 * AsciiBlocks Component
 *
 * A dense field of ASCII block characters with visible wave interference.
 * Waves directly control character density and brightness.
 * Cursors sweep across like typing/editing text.
 *
 * The effect: flowing patterns of density that shift and morph,
 * with cursor sweeps evoking the act of writing and editing copy.
 */

interface Props {
  class?: string;
}

const { class: className } = Astro.props;
const canvasId = `ascii-blocks-${Math.random().toString(36).substr(2, 9)}`;
---

<div
  class={`ascii-blocks ${className || ''}`.trim()}
  data-ascii-blocks
>
  <canvas id={canvasId} class="ascii-blocks__canvas" aria-hidden="true"></canvas>
</div>

<script>
  // Block characters from sparse to dense
  const BLOCKS = ['·', '░', '▒', '▓', '█'];

  interface Cell {
    x: number;
    y: number;
    col: number;
    row: number;
    noisePhase: number;
    hue: number;
  }

  interface Cursor {
    startX: number;
    startTime: number;
    speed: number;
    direction: 1 | -1; // 1 = left-to-right, -1 = right-to-left
    trailLength: number;
  }

  function initAsciiBlocks() {
    const containers = document.querySelectorAll('[data-ascii-blocks]');

    containers.forEach((container) => {
      if (container.hasAttribute('data-initialized')) return;
      container.setAttribute('data-initialized', 'true');

      const canvas = container.querySelector('canvas') as HTMLCanvasElement;
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      // State
      let cells: Cell[] = [];
      let cursors: Cursor[] = [];
      let width = 0;
      let height = 0;
      let cols = 0;
      let rows = 0;
      let cellSize = 16;
      let animationId = 0;
      let isRunning = false;
      let startTime = 0;
      let lastCursorTime = 0;

      const config = {
        entranceDuration: 1600,
        cursorInterval: 3500, // Spawn cursors more frequently
        cursorSpeed: 0.12, // Pixels per ms
        trailLength: 80, // Width of the highlight trail
        baseOpacity: 0.25,
        peakOpacity: 0.95,
      };

      // Two dominant waves that create clear interference bands
      function getWaveValue(x: number, y: number, time: number): number {
        // Wave 1: Horizontal sweep (primary)
        const wave1 = Math.sin(x * 0.012 + time * 0.0008);

        // Wave 2: Diagonal sweep (creates interference)
        const wave2 = Math.sin((x * 0.8 + y * 0.6) * 0.01 + time * 0.0006);

        // Wave 3: Slow vertical undulation
        const wave3 = Math.sin(y * 0.015 + time * 0.0003) * 0.4;

        // Combine with interference (waves can reinforce or cancel)
        const combined = (wave1 + wave2 + wave3) / 2.4;

        // Map from [-1, 1] to [0, 1]
        return (combined + 1) / 2;
      }

      // Cursor creates a vertical sweep with trailing highlight
      function getCursorValue(x: number, time: number): number {
        let total = 0;

        for (const cursor of cursors) {
          const elapsed = time - cursor.startTime;
          const cursorX = cursor.startX + elapsed * cursor.speed * cursor.direction;

          // Distance from cursor position
          const distFromCursor = (x - cursorX) * cursor.direction;

          // Cursor head (bright leading edge)
          if (distFromCursor >= -8 && distFromCursor <= 0) {
            const headIntensity = 1 - Math.abs(distFromCursor) / 8;
            total += headIntensity * 0.9;
          }

          // Trail behind cursor (fading highlight like selected text)
          if (distFromCursor > 0 && distFromCursor < cursor.trailLength) {
            const trailIntensity = 1 - distFromCursor / cursor.trailLength;
            // Ease out for smoother fade
            total += trailIntensity * trailIntensity * 0.5;
          }
        }

        return Math.min(1, total);
      }

      function spawnCursor(time: number) {
        const direction = Math.random() > 0.5 ? 1 : -1 as 1 | -1;
        cursors.push({
          startX: direction === 1 ? -20 : width + 20,
          startTime: time,
          speed: config.cursorSpeed * (0.8 + Math.random() * 0.4),
          direction,
          trailLength: config.trailLength * (0.7 + Math.random() * 0.6),
        });

        // Clean old cursors that have moved off screen
        cursors = cursors.filter(c => {
          const elapsed = time - c.startTime;
          const cursorX = c.startX + elapsed * c.speed * c.direction;
          return c.direction === 1 ? cursorX < width + 200 : cursorX > -200;
        });
      }

      function setupCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = Math.min(window.devicePixelRatio || 1, 2);

        width = rect.width;
        height = rect.height;

        // Responsive cell size
        if (rect.width < 480) {
          cellSize = 12;
        } else if (rect.width < 768) {
          cellSize = 14;
        } else if (rect.width < 1024) {
          cellSize = 16;
        } else {
          cellSize = 18;
        }

        cols = Math.ceil(rect.width / cellSize) + 1;
        rows = Math.ceil(rect.height / cellSize) + 1;

        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        canvas.style.width = `${rect.width}px`;
        canvas.style.height = `${rect.height}px`;

        ctx.scale(dpr, dpr);

        // Create cells
        cells = [];
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            cells.push({
              x: col * cellSize,
              y: row * cellSize,
              col,
              row,
              noisePhase: Math.random() * Math.PI * 2,
              hue: 28 + Math.random() * 14,
            });
          }
        }

        cursors = [];
      }

      function easeOutExpo(t: number): number {
        return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
      }

      function animate(timestamp: number) {
        if (!isRunning) return;

        if (startTime === 0) {
          startTime = timestamp;
          lastCursorTime = timestamp;
        }

        const time = timestamp - startTime;
        const entranceProgress = Math.min(1, easeOutExpo(time / config.entranceDuration));

        // Spawn cursors periodically
        if (time - lastCursorTime > config.cursorInterval && time > 600) {
          spawnCursor(time);
          lastCursorTime = time;
        }

        ctx.clearRect(0, 0, width, height);
        ctx.font = `${cellSize}px "Geist Mono", ui-monospace, monospace`;
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';

        for (const cell of cells) {
          const cx = cell.x + cellSize / 2;
          const cy = cell.y + cellSize / 2;

          // Get wave value (0-1) - this drives the base pattern
          const waveValue = getWaveValue(cx, cy, time);

          // Get cursor value (0-1) - adds typing/editing highlight
          const cursorValue = getCursorValue(cx, time);

          // Small per-cell shimmer
          const shimmer = Math.sin(time * 0.002 + cell.noisePhase) * 0.08;

          // Combined intensity
          const intensity = Math.min(1, waveValue + shimmer + cursorValue * 0.8);

          // Entrance animation (sweep from left)
          const entranceDelay = (cell.x / width) * 0.4;
          const cellEntrance = Math.max(0, Math.min(1,
            (entranceProgress - entranceDelay) / (1 - entranceDelay * 0.5)
          ));

          if (cellEntrance <= 0) continue;

          // Character based on intensity
          // Map intensity 0-1 to character index
          const charIndex = Math.min(BLOCKS.length - 1, Math.floor(intensity * BLOCKS.length));
          const char = BLOCKS[charIndex];

          // Opacity: wave creates visible variation, cursor boosts for highlight effect
          const baseOpacity = config.baseOpacity + (config.peakOpacity - config.baseOpacity) * (waveValue * 0.6);
          const finalOpacity = Math.min(1, baseOpacity + cursorValue * 0.6) * cellEntrance;

          // Color: warmer and brighter at higher intensity, cursor adds highlight tint
          const saturation = 0.02 + intensity * 0.14;
          const lightness = 30 + intensity * 50;
          const hue = cell.hue + cursorValue * 10;

          ctx.fillStyle = `oklch(${lightness}% ${saturation} ${hue} / ${finalOpacity})`;
          ctx.fillText(char, cell.x, cell.y);

          // Extra highlight glow for cursor peaks (like text selection)
          if (cursorValue > 0.5) {
            const glowOpacity = (cursorValue - 0.5) * 0.4 * cellEntrance;
            ctx.fillStyle = `oklch(75% 0.15 45 / ${glowOpacity})`;
            ctx.fillText(char, cell.x, cell.y);
          }
        }

        animationId = requestAnimationFrame(animate);
      }

      function start() {
        if (isRunning) return;
        isRunning = true;
        startTime = 0;
        animationId = requestAnimationFrame(animate);
      }

      function pause() {
        isRunning = false;
        cancelAnimationFrame(animationId);
      }

      function handleVisibility() {
        if (document.hidden) {
          pause();
        } else if (container.hasAttribute('data-visible')) {
          start();
        }
      }

      document.addEventListener('visibilitychange', handleVisibility);

      const resizeObserver = new ResizeObserver(() => {
        setupCanvas();
      });
      resizeObserver.observe(container);

      const intersectionObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              container.setAttribute('data-visible', 'true');
              start();
            } else {
              container.removeAttribute('data-visible');
              pause();
            }
          });
        },
        { threshold: 0.1 }
      );
      intersectionObserver.observe(container);

      // Wait for font to load before starting to avoid visual artifacts
      async function waitForFont() {
        try {
          await document.fonts.load('16px "Geist Mono"');
        } catch {
          // Font API not supported or font not found, proceed anyway
        }
        setupCanvas();
      }

      waitForFont();

      (container as HTMLElement & { destroy?: () => void }).destroy = () => {
        pause();
        resizeObserver.disconnect();
        intersectionObserver.disconnect();
        document.removeEventListener('visibilitychange', handleVisibility);
      };
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAsciiBlocks);
  } else {
    initAsciiBlocks();
  }

  document.addEventListener('astro:page-load', initAsciiBlocks);
</script>

<style>
  .ascii-blocks {
    position: relative;
    width: 100%;
    /* Generous height on mobile for visual impact */
    height: 180px;
    overflow: hidden;

    /* Softer fade on mobile for more breathing room */
    mask-image:
      linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%),
      linear-gradient(to right, transparent 0%, black 6%, black 94%, transparent 100%);
    mask-composite: intersect;
    -webkit-mask-image:
      linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%),
      linear-gradient(to right, transparent 0%, black 6%, black 94%, transparent 100%);
    -webkit-mask-composite: source-in;
  }

  @media (min-width: 375px) {
    .ascii-blocks {
      height: 200px;
    }
  }

  @media (min-width: 480px) {
    .ascii-blocks {
      height: 240px;
      /* Tighter fade on larger screens */
      mask-image:
        linear-gradient(to bottom, transparent 0%, black 12%, black 88%, transparent 100%),
        linear-gradient(to right, transparent 0%, black 4%, black 96%, transparent 100%);
      -webkit-mask-image:
        linear-gradient(to bottom, transparent 0%, black 12%, black 88%, transparent 100%),
        linear-gradient(to right, transparent 0%, black 4%, black 96%, transparent 100%);
    }
  }

  @media (min-width: 768px) {
    .ascii-blocks {
      height: 300px;
    }
  }

  @media (min-width: 1024px) {
    .ascii-blocks {
      height: 360px;
    }
  }

  @media (min-width: 1280px) {
    .ascii-blocks {
      height: 420px;
    }
  }

  .ascii-blocks__canvas {
    display: block;
    width: 100%;
    height: 100%;
  }

  @media (prefers-reduced-motion: reduce) {
    .ascii-blocks__canvas {
      opacity: 0.35;
    }
  }
</style>
